					Vert.x:

What is Eclipse Vert.x ?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

toolkit is nothing but you can embed into any exiting applications written by using language or framework or lib.

Framework is infrastructure for building application end to end , in order to apps written in frameworks , we need framework runtimes such as spring.

 Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.

Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Now a days, Vertx has been standardized only three languages - java,kotlin,groovy.

Vert.x doesn't preach about what language is best — you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.

How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                    compilers
                        |
                      .class
                        |
                       jvm
.....................................................................................
 		Building block of Vertx-Vertx Architecture
.....................................................................................

NonBlocking io:
...............


IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.

The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.

File Descriptor:
..................

File descriptor or file descriptor table is nothing but , it is "c" program which has all information about  io opertaions.

Fd is bridge between application runtime/process and io devices.


Blocking io code in java:
........................

blocking network socket app.


import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class BlockingEco {
    public static void main(String[] args) throws Throwable {
        //this api interally communicates network interface card
        ServerSocket server = new ServerSocket();
        server.bind(new InetSocketAddress(3000));
        System.out.println("Blocking Socket : listening for new Request");
        while (true) {   // <1>
            Socket socket = server.accept();
            //each incomming request(socket request) allocate in a separate thread
            new Thread(clientHandler(socket)).start();
        }
    }

    private static Runnable clientHandler(Socket socket) {
        return () -> {

            try (
                    BufferedReader reader = new BufferedReader(
                            new InputStreamReader(socket.getInputStream()));
                    PrintWriter writer = new PrintWriter(
                            new OutputStreamWriter(socket.getOutputStream()))) {
                String line = "";
                while (!"/quit".equals(line)) {
                    line = reader.readLine();      // <2>
                    System.out.println("~ " + line);
                    writer.write(line + "\n");  // <3>
                    writer.flush();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
    }

}

Why not blocking?

Blocking APIs waste resources, increase costs


The main problem with the code above ,is that it allocates a new thread for each incoming connection(request) and threads are anything but cheap resources. 

A thread needs memory, and the more threads you have, the more you put pressure on the operating system kernel scheduler, as it needs to give CPU time to the thread

 Input/output operations such as readLine and write may block the thread, meaning that it is being parked by the operating system. This happens for two reasons:

A read operation may be waiting for data to arrive from the network.
A write operation may have to wait for buffers to be drained if they are full from a previous write operation

NonBlocking io  = IO Multiplxing (Nonblocking io,SIGIO,POSX_IO FUNCTIONS)

Today there are two io programming models = blocking and io multiplexing(Non,async)

Generally all webservers work based on "Request per thread Model".

2000,C10K - concurrently handling ten thousand connections.

2000, Linux operating system introduced a new api for io operations which does not block thread - "select"	

non blocking io operation: 

1.select + read - first non blocking io operation introduced in linux operating system.

2.poll - second non blocking io operation api introduced in linux. the difference is 
         poll pushing data from kernal to application process rather pulling data          from  kernal table.

3.Epoll -  this modern non blocking io api introduced in linux....

Other Operating system non blocking abstractions:

EPoll -Linux
IOCP - Windows
kqueue -mac and other open bsd versions.
.....................................................................................
java and non blocking:
......................

Does java support non blocking apis?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"-NONBlocking IO.

NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}
Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 
->It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
->Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

->This is why, in practice, developers rarely deal with Java NIO. 
.......................................................................................................

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        	     Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Objective of VertX:
   
    100% non blocking applications on jvm.


NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


/////////////////////////////////////////////////////////////////////////////////////

Vertx Runtime:

Vertx run time is powered by non blocking io arch

Vertx uses event loops
 -event loops are used to process events which are dispatched by kernal.
 -Event loops are just threads to process incoming events from kernal

Event :

  collection of event and data
  How to read data?
    you need handler- callback functions


Vertx uses multi core event loop threads where as node js has only one event loop thread.

Vertx uses per cpu core - 2 event loop, lets say i have 12 cores - 12 *2 =24 event loops.
....................................................................................

Lets enter into vertx app; how to build non blocking and async apps:
....................................................................

Lets code:

-Vertx Project setup
   -Maven Project
   -Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project
.................................................................................
			 How to create vertx cli project..

https://start.vertx.io/

Vertx application can be small to big enterprise microservice application.

Like spring , starts with spring-core , after that ,spring-mvc,spring-data....(modules)

Vertx also begins modules

vertx-core ,vertx-web,vertx-data..............etc...

vertx-core:

How to run vertx app?

Every Vertx apps will have entry point, configured in pom.xml

 <main.verticle>com.amex.MainVerticle</main.verticle>
 <launcher.class>io.vertx.core.Launcher</launcher.class>

How to run vertx apps?

1.compile the code and execute - dev mode.

mvnw clean compile exec:java

[INFO] Scanning for projects...
[INFO] 
[INFO] -----------------------< com.amex:vertxcoreapp >------------------------
[INFO] Building vertxcoreapp 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ vertxcoreapp ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ vertxcoreapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory E:\session\AMex\2023\vertxcoreapp\src\main\resources
[INFO]                                                                                         
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ vertxcoreapp ---            
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to E:\session\AMex\2023\vertxcoreapp\target\classes
[INFO] 
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ vertxcoreapp ---
HTTP server started on port 8888
Oct 16, 2023 2:22:56 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle

By default vertx offers some Webservice which is running in port 8888

http://localhost:8888/

2.Creating production apps -deployment 

mvnw clean package 

 This command gives two jars.
  
 Regular jar  
 fat jar

How to run ?

java -jar target/vertxcoreapp-1.0.0-SNAPSHOT-fat.jar
.....................................................................................
			   vertx Core concepts
.....................................................................................

Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.

Vertx Engine is a java class, represented as interface in the io.vertx.core package

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler)

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles

package com.amex;

import io.vertx.core.Vertx;

public class HelloVertx {
  public static void main(String[] args) {
    System.out.println("Creating vertx app");
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.getClass());

    System.out.println("Main thread" + Thread.currentThread().getName());
    //create simple web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println("Server");
      System.out.println("Vertx thread : " + Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}
.....................................................................................
Vertx modules:
...............
vertx-core
vertx-web
vertx-data
vertx-microservices
etc...


Verticles
Threading modles
callbacks
Promises
Futures


Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.

What is deployment?

The action of bringing "resources" into effective action

In vertx, Brining Resources ready  for computation.

Resources:
 -Thread creation /allocation
 -binding an object with that thread
 -Register all event handlers in case of event driven programming
 -Allocate memory if required for data/other 
 -Ensures that other depenendant resources or ready.

-It is based on design pattern called "Actor-like Model"
-Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init   - called when verticle being initalized
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment


if you are writing any verticle class, you cant use "Verticle" Interface directly.

Vertx provides an implementation abstract class called "AbstractVerticle" class.

io.vertx.core.AbstractVerticle
io.vertx.rxjava3.core.AbstractVerticle
io.vertx.rxjava.core.AbstractVerticle

How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}
package com.amex;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class MainVerticle extends AbstractVerticle {
  //override verticle life cycle methods

  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start method is called");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop method is called");
  }
}
.....................................................................................
	          How to create multiple verticles and deploy them
....................................................................................

There are many ways
1.within main verticle and deploy other verticles
2.write simple java class and through which you can deployment
3.Vertx provides a runner class through which also you can deploymnet

1.within main verticle and deploy other verticles


package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class MainVerticle extends AbstractVerticle {
  //override verticle life cycle methods
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start method is called");
    //deploy Greeter Verticle
    //vertx variable is already available within every verticle we create.
    // vertx.deployVerticle(new GreeterVerticle());
    //vertx.deployVerticle(GreeterVerticle.class.getName());
    vertx.deployVerticle("com.amex.verticles.GreeterVerticle");

  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop method is called");
    vertx.undeploy("com.amex.verticles.GreeterVerticle");
  }
}
....................................................................................

From plain java code how to deploy verticles?
.............................................

package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.Vertx;

public class VertlcleDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new GreeterVerticle());
  }
}

This code will not call life cycle method like stop.
This is not recommended way of deploying verticles.

Runner/Lanucher class
.......................
Lanuching vertx applications using main method without using "maven/gradle" configuration.
package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;

public class LanucherDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", LanucherDeployer.class.getName());
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Deployer starting");
    vertx.deployVerticle(new GreeterVerticle());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Deployer ending");
  }
}

Output:
Deployer starting
GreeterVerticle
Oct 16, 2023 4:37:14 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
GreeterVerticle has been stopped
Deployer ending
.....................................................................................
			  Vertx Coding Style
...................................................................................

Patterns to write non blocking apps:

1.callback style -traditionals way.
2.Reactive style -Streaming pattern

Non blocking apis
1.timer
2.http
3.fs
4.socket
5.database
etc.......

Callback/Listener Style:
1.Future
2.Promises

if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".


Handler Function /Callback function/Listener function:
.......................................................
1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop thread starts processing event by assinging a handler function.

What is handler function/callback function/listener function for?

 "To handle async success /failure result"
     "The result of async opertion could be either success or failure".

io.vertx.Future:

-it is interface used to handle async success/failure results.
-vertx uses Future(Object) to represent "Asynchronous" Results
-Future is like transport object to transport data between caller and callee in async  manner

Caller -------Future-----Callee


What type of data Future can carry?

-Success--------|
                  ---->Future
-Failure--------|


AsynResult<T>:

Encapsulates the result of an asynchronous operation.

Object which has either success data or failure data.

If it failed then the cause of the failure is available with cause().

If it succeeded then the actual result is available with result()


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation

 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.

Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure



AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success
....................................................................................

Use case: Get Empty Future

package com.amex.futures;

import io.vertx.core.*;

public class FutureDemoVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureDemoVerticle.class.getName());
  }

  //Callee
  //create simple future and return no Result.
  public Future<Void> getEmptyFuture() {
    //create Future Object : Anonymous pattern using java inner class
//    Future<Void> future = Future.future(new Handler<Promise<Void>>() {
//      @Override
//      public void handle(Promise<Void> event) {
//        event.complete();
//      }
//    });
    // create Future Object : using lambda pattern:It is recommended
    Future<Void> future = Future.future(event -> {
      event.complete();
    });
    return future;
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Future Verticle");
    //caller
//    getEmptyFuture().onComplete(new Handler<AsyncResult<Void>>() {
//      @Override
//      public void handle(AsyncResult<Void> event) {
//        //here only we grab result
//        if (event.succeeded()) {
//          System.out.println("Success");
//          event.result();
//        } else {
//          System.out.println("Failed");
//          System.out.println(event.cause().getMessage());
//        }
//      }
//    });
    getEmptyFuture().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("Success");
        event.result();
      } else {
        System.out.println("Failed");
        System.out.println(event.cause().getMessage());
      }
    });
  }
}
....................................................................................

Future with data,error, data and error:
......................................
package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureWithData extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithData.class.getName());
  }

  //Return data with Future.
  public Future<String> sayHello() {
    return Future.future(future -> future.complete("Hello"));
  }

  //return error data with Future
  public Future<String> getError() {
    return Future.future(future -> future.fail("Something went wrong!"));
  }

  //future with biz logic
  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }


  @Override
  public void start() throws Exception {
    super.start();
    //subscribe future .
    sayHello().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    //grab error Message
    getError().onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      }
    });
    //login with success and error
    login("admin", "admin").onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      } else {
        System.out.println(event.result());
      }
    });
    //login with failure data
    login("foo", "bar").onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      } else {
        System.out.println(event.result());
      }
    });
  }
}
.....................................................................................
Shortcuts for Listener Code;
.............................

Listener api Which returns Future.

Syntax:
someApi().onComplete(Handler<AsynResult>)
someApi().onSuccess(res->{});
someApi().onError(err->{});
someApi().onSuccess(res->{}).onError(err->{});
someApi().onSuccess(System.out::println).onError(System.out::println);

package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureWithData extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithData.class.getName());
  }

  //Return data with Future.
  public Future<String> sayHello() {
    return Future.future(future -> future.complete("Hello"));
  }

  //return error data with Future
  public Future<String> getError() {
    return Future.future(future -> future.fail("Something went wrong!"));
  }

  //future with biz logic
  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    //short cut apis
    //sayHello().onSuccess(res -> System.out.println(res));
    sayHello().onSuccess(System.out::println);
    getError().onFailure(System.out::println);
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}
.....................................................................................
			 Future Object Creation Patterns
....................................................................................

Pattern 1: Factory Method pattern

Future.future()

  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }

Pattern 2:

Future.succeedFuture() - Returns success Result
Future.failedFuture() -> Returns failure Result.

 public Future<String> auth(String userName, String password) {
    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    }
    return Future.failedFuture("Login Failed");
  }

Pattern 3 :
 Instead of Returning Future, We can pass function as Parameter(Higher Order Function)

    authenticat("admin", "admin", handler -> {
      if (handler.failed()) {
        System.out.println(handler.cause().getMessage());
      } else {
        System.out.println(handler.result());
      }
    });

Full code:
package com.amex.futures;

import io.vertx.core.*;

public class FutureObjectCreationPatterns extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureObjectCreationPatterns.class.getName());
  }

  //Pattern 1:
  public Future<String> login(String userName, String password) {
    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });
  }

  //Pattern 2:
  public Future<String> auth(String userName, String password) {
    if (userName.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login Success");
    }
    return Future.failedFuture("Login Failed");
  }

  //Pattern 3: Function as parameter : Higher order function
  public void authenticat(String userName, String password, Handler<AsyncResult<String>> asyncHandler) {
    if (userName.equals("admin") && password.equals("admin")) {
      asyncHandler.handle(Future.succeededFuture("Login success"));
    } else {
      asyncHandler.handle(Future.failedFuture("Login Failed"));
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //pattern 1:
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    // pattern 2:
    auth("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    //Pattern 3:
    authenticat("admin", "admin", handler -> {
      if (handler.failed()) {
        System.out.println(handler.cause().getMessage());
      } else {
        System.out.println(handler.result());
      }
    });
  }
}
.....................................................................................
		     Callback Chaining - Nested Callbacks
.....................................................................................

In Sync application, the flow will go step by step

Connection conn = DriverManager.getConnection();
Statement st = conn.createStatement();
ResultSet rows = st.executeQuery();

Here flow will go based on previous statement , one after another another.


Connection conn = DriverManager.getConnection();
Statement st = conn.createStatement();
ResultSet rows = st.executeQuery();
FormateResult()
AddResponse into http Stream
send Response to the client
....................................................................................

What if the same task can be done in functional programming or async way; Vertx

Functional sequential work flow
  Nested callbacks , callback chaining, functional style.
 
Handler function is called as callback function.

"The output of one callback is input to the another callback: nested callbacks".

 cb1
   --cb2
       --cb3
            --cbN
                  --process the result


Use Case:
   getUser() -----if user is available(success)
			|
			 -----call login method with output of getUser
			|
		 if failed
		     |
		     You throw error

Note: The output of one callback will be input to another function.
............

Code:
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

//Model class
class User {
  private String userName;
  private String password;

  public User() {
  }

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @Override
  public String toString() {
    return "User{" +
      "userName='" + userName + '\'' +
      ", password='" + password + '\'' +
      '}';
  }
}

public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackVerticle.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(userHandler -> {
      if (userHandler.succeeded()) {
        // System.out.println(userHandler.result());
        //call login method
        login(userHandler.result()).onComplete(loginHandler -> {
          if (loginHandler.succeeded()) {
            //call show dashboard
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.succeeded()) {
                System.out.println(dashboardHandler.result());
              } else {
                System.out.println(dashboardHandler.cause().getMessage());
              }
            });
          } else {
            System.out.println(loginHandler.cause().getMessage());
          }
        });
      } else {
        System.out.println(userHandler.cause().getMessage());
      }
    });
  }
}
.....................................................................................
			  Callback Hell
.....................................................................................
getUser().onComplete(userHandler -> {
      if (userHandler.succeeded()) {
        // System.out.println(userHandler.result());
        //call login method
        login(userHandler.result()).onComplete(loginHandler -> {
          if (loginHandler.succeeded()) {
            //call show dashboard
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.succeeded()) {
                System.out.println(dashboardHandler.result());
              } else {
                System.out.println(dashboardHandler.cause().getMessage());
              }
            });
          } else {
            System.out.println(loginHandler.cause().getMessage());
          }
        });
      } else {
        System.out.println(userHandler.cause().getMessage());
      }
    });

Look at the above code, ask your self.

1.IS it easy to understand
2.is it easy to scale
3.Is it easy to maintain

No!

 This is called  callback hell; The callback hell is way of writing complex callback based program.

Can we escape from the callback hell problem, or how to write better callback based programming.

Yes!.

Soultion 1:
............
Using onSuccess and onFailure.
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackVerticle.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
    getUser().onSuccess(user -> {
      login(user).onSuccess(status -> {
        showDashboard(status).onSuccess(page -> {
          System.out.println(page);
        }).onFailure(err -> System.out.println(err));
      }).onFailure(loginErr -> {
        System.out.println(loginErr.getMessage());
      });
    }).onFailure(userErr -> {
      System.out.println(userErr.getMessage());
    });
  }
}
........................

Solution 2: Using Future.compose method

Used to chain multiple callbacks in more readable way.
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackHellSoultion.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
//    getUser().onSuccess(user -> {
//      login(user).onSuccess(status -> {
//        showDashboard(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> System.out.println(err));
//      }).onFailure(loginErr -> {
//        System.out.println(loginErr.getMessage());
//      });
//    }).onFailure(userErr -> {
//      System.out.println(userErr.getMessage());
//    });

//    //solution 2: Using Future.compose method
    getUser().compose(user -> {
      return login(user);
    }).compose(status -> {
      return showDashboard(status);
    }).onSuccess(res -> {
      System.out.println(res);
    }).onFailure(err -> {
      System.out.println(err.getMessage());
    });

  }
}

Compose Refactoring: Using Lambdas

//Solution 2.1: Using Future.compose method lambda refactoring.

    getUser()
      .compose(user -> login(user))
      .compose(status -> showDashboard(status))
      .onSuccess(res -> {
        System.out.println(res);
      }).onFailure(err -> {
        System.out.println(err.getMessage());
      });

    //Soution 2.2 : Using Future.compose using Method reference
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
..........................
Callback Hell Solution code:
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackHellSoultion.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
//    getUser().onSuccess(user -> {
//      login(user).onSuccess(status -> {
//        showDashboard(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> System.out.println(err));
//      }).onFailure(loginErr -> {
//        System.out.println(loginErr.getMessage());
//      });
//    }).onFailure(userErr -> {
//      System.out.println(userErr.getMessage());
//    });

//    //solution 2: Using Future.compose method
//    getUser().compose(user -> {
//      return login(user);
//    }).compose(status -> {
//      return showDashboard(status);
//    }).onSuccess(res -> {
//      System.out.println(res);
//    }).onFailure(err -> {
//      System.out.println(err.getMessage());
//    });
    //Solution 2.1: Using Future.compose method lambda refactoring.

//    getUser()
//      .compose(user -> login(user))
//      .compose(status -> showDashboard(status))
//      .onSuccess(res -> {
//        System.out.println(res);
//      }).onFailure(err -> {
//        System.out.println(err.getMessage());
//      });
    //Soution 2.2 : Using Future.compose using Method reference
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}
.....................................................................................
			  Advanced Composition: CompositeFuture
....................................................................................

Lets say i have three methods

-startDbServer
-startHttpServer
-startConfigServer

 I need to ensure that my app must be initalized only , all servers are up, if any one server is failed, stop all servers/ dont initialize my app.

Future Coordination:
  Coordination of multiple futures can be achived with Vertx Futures.

Vertx supports concurrent composition(running serveral async operations in parall) and code looks like sequential - chaining async operations...

Syntax:
 CompositeFuture.all(f1,f2,f3,f4,f5,f6)

  -All composition waits until all futures are successfull or any one failed.


 CompositeFuture.any(f1,f2,f3,f4,f5,f6)
    Any one Compostion waits for any one succeedFuture.
   

package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CompositFutureVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CompositFutureVerticle.class.getName());
  }

  //start Db server
  public Future<String> startDbServer() {
    System.out.println("Db Server started");
    return Future.succeededFuture("Db Server is Up");
  }

  //start web server
  public Future<String> startWebServer() {
    System.out.println("Web Server is started");
   // return Future.succeededFuture("WebServer is Up");
    return Future.failedFuture("Failed WebServer startup");
  }

  //config Server
  public Future<String> startConfigServer() {
    System.out.println("Config Server is started");
    return Future.succeededFuture("ConfigServer is Up");
  }

  @Override
  public void start() throws Exception {
    super.start();
    Future<String> dbServer = startDbServer();
    Future<String> webServer = startWebServer();
    Future<String> configServer = startConfigServer();

    CompositeFuture.all(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
        //do something....
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

    System.out.println("...Any...");
    CompositeFuture.any(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
        //do something....
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}









