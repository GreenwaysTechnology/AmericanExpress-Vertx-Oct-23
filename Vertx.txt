					Vert.x:

What is Eclipse Vert.x ?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

toolkit is nothing but you can embed into any exiting applications written by using language or framework or lib.

Framework is infrastructure for building application end to end , in order to apps written in frameworks , we need framework runtimes such as spring.

 Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.

Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Now a days, Vertx has been standardized only three languages - java,kotlin,groovy.

Vert.x doesn't preach about what language is best — you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.

How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                    compilers
                        |
                      .class
                        |
                       jvm
.....................................................................................
 		Building block of Vertx-Vertx Architecture
.....................................................................................

NonBlocking io:
...............


IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.

The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.

File Descriptor:
..................

File descriptor or file descriptor table is nothing but , it is "c" program which has all information about  io opertaions.

Fd is bridge between application runtime/process and io devices.


Blocking io code in java:
........................

blocking network socket app.


import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class BlockingEco {
    public static void main(String[] args) throws Throwable {
        //this api interally communicates network interface card
        ServerSocket server = new ServerSocket();
        server.bind(new InetSocketAddress(3000));
        System.out.println("Blocking Socket : listening for new Request");
        while (true) {   // <1>
            Socket socket = server.accept();
            //each incomming request(socket request) allocate in a separate thread
            new Thread(clientHandler(socket)).start();
        }
    }

    private static Runnable clientHandler(Socket socket) {
        return () -> {

            try (
                    BufferedReader reader = new BufferedReader(
                            new InputStreamReader(socket.getInputStream()));
                    PrintWriter writer = new PrintWriter(
                            new OutputStreamWriter(socket.getOutputStream()))) {
                String line = "";
                while (!"/quit".equals(line)) {
                    line = reader.readLine();      // <2>
                    System.out.println("~ " + line);
                    writer.write(line + "\n");  // <3>
                    writer.flush();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
    }

}

Why not blocking?

Blocking APIs waste resources, increase costs


The main problem with the code above ,is that it allocates a new thread for each incoming connection(request) and threads are anything but cheap resources. 

A thread needs memory, and the more threads you have, the more you put pressure on the operating system kernel scheduler, as it needs to give CPU time to the thread

 Input/output operations such as readLine and write may block the thread, meaning that it is being parked by the operating system. This happens for two reasons:

A read operation may be waiting for data to arrive from the network.
A write operation may have to wait for buffers to be drained if they are full from a previous write operation

NonBlocking io  = IO Multiplxing (Nonblocking io,SIGIO,POSX_IO FUNCTIONS)

Today there are two io programming models = blocking and io multiplexing(Non,async)

Generally all webservers work based on "Request per thread Model".

2000,C10K - concurrently handling ten thousand connections.

2000, Linux operating system introduced a new api for io operations which does not block thread - "select"	

non blocking io operation: 

1.select + read - first non blocking io operation introduced in linux operating system.

2.poll - second non blocking io operation api introduced in linux. the difference is 
         poll pushing data from kernal to application process rather pulling data          from  kernal table.

3.Epoll -  this modern non blocking io api introduced in linux....

Other Operating system non blocking abstractions:

EPoll -Linux
IOCP - Windows
kqueue -mac and other open bsd versions.
.....................................................................................
java and non blocking:
......................

Does java support non blocking apis?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"-NONBlocking IO.

NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}
Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 
->It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
->Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

->This is why, in practice, developers rarely deal with Java NIO. 
.......................................................................................................

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        	     Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Objective of VertX:
   
    100% non blocking applications on jvm.


NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


/////////////////////////////////////////////////////////////////////////////////////

Vertx Runtime:

Vertx run time is powered by non blocking io arch

Vertx uses event loops
 -event loops are used to process events which are dispatched by kernal.
 -Event loops are just threads to process incoming events from kernal

Event :

  collection of event and data
  How to read data?
    you need handler- callback functions


Vertx uses multi core event loop threads where as node js has only one event loop thread.

Vertx uses per cpu core - 2 event loop, lets say i have 12 cores - 12 *2 =24 event loops.
....................................................................................

Lets enter into vertx app; how to build non blocking and async apps:
....................................................................

Lets code:

-Vertx Project setup
   -Maven Project
   -Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project
.................................................................................
			 How to create vertx cli project..

https://start.vertx.io/

Vertx application can be small to big enterprise microservice application.

Like spring , starts with spring-core , after that ,spring-mvc,spring-data....(modules)

Vertx also begins modules

vertx-core ,vertx-web,vertx-data..............etc...

vertx-core:

How to run vertx app?

Every Vertx apps will have entry point, configured in pom.xml

 <main.verticle>com.amex.MainVerticle</main.verticle>
 <launcher.class>io.vertx.core.Launcher</launcher.class>

How to run vertx apps?

1.compile the code and execute - dev mode.

mvnw clean compile exec:java

[INFO] Scanning for projects...
[INFO] 
[INFO] -----------------------< com.amex:vertxcoreapp >------------------------
[INFO] Building vertxcoreapp 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ vertxcoreapp ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ vertxcoreapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory E:\session\AMex\2023\vertxcoreapp\src\main\resources
[INFO]                                                                                         
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ vertxcoreapp ---            
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to E:\session\AMex\2023\vertxcoreapp\target\classes
[INFO] 
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ vertxcoreapp ---
HTTP server started on port 8888
Oct 16, 2023 2:22:56 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle

By default vertx offers some Webservice which is running in port 8888

http://localhost:8888/

2.Creating production apps -deployment 

mvnw clean package 

 This command gives two jars.
  
 Regular jar  
 fat jar

How to run ?

java -jar target/vertxcoreapp-1.0.0-SNAPSHOT-fat.jar
.....................................................................................
			   vertx Core concepts
.....................................................................................

Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.

Vertx Engine is a java class, represented as interface in the io.vertx.core package

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler)

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles

package com.amex;

import io.vertx.core.Vertx;

public class HelloVertx {
  public static void main(String[] args) {
    System.out.println("Creating vertx app");
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.getClass());

    System.out.println("Main thread" + Thread.currentThread().getName());
    //create simple web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println("Server");
      System.out.println("Vertx thread : " + Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}
.....................................................................................
Vertx modules:
...............
vertx-core
vertx-web
vertx-data
vertx-microservices
etc...


Verticles
Threading modles
callbacks
Promises
Futures


Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.

What is deployment?

The action of bringing "resources" into effective action

In vertx, Brining Resources ready  for computation.

Resources:
 -Thread creation /allocation
 -binding an object with that thread
 -Register all event handlers in case of event driven programming
 -Allocate memory if required for data/other 
 -Ensures that other depenendant resources or ready.

-It is based on design pattern called "Actor-like Model"
-Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init   - called when verticle being initalized
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment


if you are writing any verticle class, you cant use "Verticle" Interface directly.

Vertx provides an implementation abstract class called "AbstractVerticle" class.

io.vertx.core.AbstractVerticle
io.vertx.rxjava3.core.AbstractVerticle
io.vertx.rxjava.core.AbstractVerticle

How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}
package com.amex;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class MainVerticle extends AbstractVerticle {
  //override verticle life cycle methods

  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start method is called");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop method is called");
  }
}
.....................................................................................
	          How to create multiple verticles and deploy them
....................................................................................

There are many ways
1.within main verticle and deploy other verticles
2.write simple java class and through which you can deployment
3.Vertx provides a runner class through which also you can deploymnet

1.within main verticle and deploy other verticles


package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class MainVerticle extends AbstractVerticle {
  //override verticle life cycle methods
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start method is called");
    //deploy Greeter Verticle
    //vertx variable is already available within every verticle we create.
    // vertx.deployVerticle(new GreeterVerticle());
    //vertx.deployVerticle(GreeterVerticle.class.getName());
    vertx.deployVerticle("com.amex.verticles.GreeterVerticle");

  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop method is called");
    vertx.undeploy("com.amex.verticles.GreeterVerticle");
  }
}
....................................................................................

From plain java code how to deploy verticles?
.............................................

package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.Vertx;

public class VertlcleDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new GreeterVerticle());
  }
}

This code will not call life cycle method like stop.
This is not recommended way of deploying verticles.

Runner/Lanucher class
.......................
Lanuching vertx applications using main method without using "maven/gradle" configuration.
package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;

public class LanucherDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", LanucherDeployer.class.getName());
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Deployer starting");
    vertx.deployVerticle(new GreeterVerticle());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Deployer ending");
  }
}

Output:
Deployer starting
GreeterVerticle
Oct 16, 2023 4:37:14 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
GreeterVerticle has been stopped
Deployer ending
.....................................................................................
			  Vertx Coding Style
...................................................................................

Patterns to write non blocking apps:

1.callback style -traditionals way.
2.Reactive style -Streaming pattern

Non blocking apis
1.timer
2.http
3.fs
4.socket
5.database
etc.......

Callback/Listener Style:
1.Future
2.Promises

if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".


Handler Function /Callback function/Listener function:
.......................................................
1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop thread starts processing event by assinging a handler function.

What is handler function/callback function/listener function for?

 "To handle async success /failure result"
     "The result of async opertion could be either success or failure".

io.vertx.Future:

-it is interface used to handle async success/failure results.
-vertx uses Future(Object) to represent "Asynchronous" Results
-Future is like transport object to transport data between caller and callee in async  manner

Caller -------Future-----Callee


What type of data Future can carry?

-Success--------|
                  ---->Future
-Failure--------|


AsynResult<T>:

Encapsulates the result of an asynchronous operation.

Object which has either success data or failure data.

If it failed then the cause of the failure is available with cause().

If it succeeded then the actual result is available with result()


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation

 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.

Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure



AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success
....................................................................................

Use case: Get Empty Future

package com.amex.futures;

import io.vertx.core.*;

public class FutureDemoVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureDemoVerticle.class.getName());
  }

  //Callee
  //create simple future and return no Result.
  public Future<Void> getEmptyFuture() {
    //create Future Object : Anonymous pattern using java inner class
//    Future<Void> future = Future.future(new Handler<Promise<Void>>() {
//      @Override
//      public void handle(Promise<Void> event) {
//        event.complete();
//      }
//    });
    // create Future Object : using lambda pattern:It is recommended
    Future<Void> future = Future.future(event -> {
      event.complete();
    });
    return future;
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Future Verticle");
    //caller
//    getEmptyFuture().onComplete(new Handler<AsyncResult<Void>>() {
//      @Override
//      public void handle(AsyncResult<Void> event) {
//        //here only we grab result
//        if (event.succeeded()) {
//          System.out.println("Success");
//          event.result();
//        } else {
//          System.out.println("Failed");
//          System.out.println(event.cause().getMessage());
//        }
//      }
//    });
    getEmptyFuture().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("Success");
        event.result();
      } else {
        System.out.println("Failed");
        System.out.println(event.cause().getMessage());
      }
    });
  }
}
....................................................................................

Future with data,error, data and error:
......................................
package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureWithData extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithData.class.getName());
  }

  //Return data with Future.
  public Future<String> sayHello() {
    return Future.future(future -> future.complete("Hello"));
  }

  //return error data with Future
  public Future<String> getError() {
    return Future.future(future -> future.fail("Something went wrong!"));
  }

  //future with biz logic
  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }


  @Override
  public void start() throws Exception {
    super.start();
    //subscribe future .
    sayHello().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    //grab error Message
    getError().onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      }
    });
    //login with success and error
    login("admin", "admin").onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      } else {
        System.out.println(event.result());
      }
    });
    //login with failure data
    login("foo", "bar").onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      } else {
        System.out.println(event.result());
      }
    });
  }
}
.....................................................................................
Shortcuts for Listener Code;
.............................

Listener api Which returns Future.

Syntax:
someApi().onComplete(Handler<AsynResult>)
someApi().onSuccess(res->{});
someApi().onError(err->{});
someApi().onSuccess(res->{}).onError(err->{});
someApi().onSuccess(System.out::println).onError(System.out::println);

package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureWithData extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithData.class.getName());
  }

  //Return data with Future.
  public Future<String> sayHello() {
    return Future.future(future -> future.complete("Hello"));
  }

  //return error data with Future
  public Future<String> getError() {
    return Future.future(future -> future.fail("Something went wrong!"));
  }

  //future with biz logic
  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    //short cut apis
    //sayHello().onSuccess(res -> System.out.println(res));
    sayHello().onSuccess(System.out::println);
    getError().onFailure(System.out::println);
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}
.....................................................................................
			 Future Object Creation Patterns
....................................................................................

Pattern 1: Factory Method pattern

Future.future()

  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }

Pattern 2:

Future.succeedFuture() - Returns success Result
Future.failedFuture() -> Returns failure Result.

 public Future<String> auth(String userName, String password) {
    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    }
    return Future.failedFuture("Login Failed");
  }

Pattern 3 :
 Instead of Returning Future, We can pass function as Parameter(Higher Order Function)

    authenticat("admin", "admin", handler -> {
      if (handler.failed()) {
        System.out.println(handler.cause().getMessage());
      } else {
        System.out.println(handler.result());
      }
    });

Full code:
package com.amex.futures;

import io.vertx.core.*;

public class FutureObjectCreationPatterns extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureObjectCreationPatterns.class.getName());
  }

  //Pattern 1:
  public Future<String> login(String userName, String password) {
    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });
  }

  //Pattern 2:
  public Future<String> auth(String userName, String password) {
    if (userName.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login Success");
    }
    return Future.failedFuture("Login Failed");
  }

  //Pattern 3: Function as parameter : Higher order function
  public void authenticat(String userName, String password, Handler<AsyncResult<String>> asyncHandler) {
    if (userName.equals("admin") && password.equals("admin")) {
      asyncHandler.handle(Future.succeededFuture("Login success"));
    } else {
      asyncHandler.handle(Future.failedFuture("Login Failed"));
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //pattern 1:
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    // pattern 2:
    auth("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    //Pattern 3:
    authenticat("admin", "admin", handler -> {
      if (handler.failed()) {
        System.out.println(handler.cause().getMessage());
      } else {
        System.out.println(handler.result());
      }
    });
  }
}
.....................................................................................
		     Callback Chaining - Nested Callbacks
.....................................................................................

In Sync application, the flow will go step by step

Connection conn = DriverManager.getConnection();
Statement st = conn.createStatement();
ResultSet rows = st.executeQuery();

Here flow will go based on previous statement , one after another another.


Connection conn = DriverManager.getConnection();
Statement st = conn.createStatement();
ResultSet rows = st.executeQuery();
FormateResult()
AddResponse into http Stream
send Response to the client
....................................................................................

What if the same task can be done in functional programming or async way; Vertx

Functional sequential work flow
  Nested callbacks , callback chaining, functional style.
 
Handler function is called as callback function.

"The output of one callback is input to the another callback: nested callbacks".

 cb1
   --cb2
       --cb3
            --cbN
                  --process the result


Use Case:
   getUser() -----if user is available(success)
			|
			 -----call login method with output of getUser
			|
		 if failed
		     |
		     You throw error

Note: The output of one callback will be input to another function.
............

Code:
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

//Model class
class User {
  private String userName;
  private String password;

  public User() {
  }

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @Override
  public String toString() {
    return "User{" +
      "userName='" + userName + '\'' +
      ", password='" + password + '\'' +
      '}';
  }
}

public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackVerticle.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(userHandler -> {
      if (userHandler.succeeded()) {
        // System.out.println(userHandler.result());
        //call login method
        login(userHandler.result()).onComplete(loginHandler -> {
          if (loginHandler.succeeded()) {
            //call show dashboard
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.succeeded()) {
                System.out.println(dashboardHandler.result());
              } else {
                System.out.println(dashboardHandler.cause().getMessage());
              }
            });
          } else {
            System.out.println(loginHandler.cause().getMessage());
          }
        });
      } else {
        System.out.println(userHandler.cause().getMessage());
      }
    });
  }
}
.....................................................................................
			  Callback Hell
.....................................................................................
getUser().onComplete(userHandler -> {
      if (userHandler.succeeded()) {
        // System.out.println(userHandler.result());
        //call login method
        login(userHandler.result()).onComplete(loginHandler -> {
          if (loginHandler.succeeded()) {
            //call show dashboard
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.succeeded()) {
                System.out.println(dashboardHandler.result());
              } else {
                System.out.println(dashboardHandler.cause().getMessage());
              }
            });
          } else {
            System.out.println(loginHandler.cause().getMessage());
          }
        });
      } else {
        System.out.println(userHandler.cause().getMessage());
      }
    });

Look at the above code, ask your self.

1.IS it easy to understand
2.is it easy to scale
3.Is it easy to maintain

No!

 This is called  callback hell; The callback hell is way of writing complex callback based program.

Can we escape from the callback hell problem, or how to write better callback based programming.

Yes!.

Soultion 1:
............
Using onSuccess and onFailure.
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackVerticle.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
    getUser().onSuccess(user -> {
      login(user).onSuccess(status -> {
        showDashboard(status).onSuccess(page -> {
          System.out.println(page);
        }).onFailure(err -> System.out.println(err));
      }).onFailure(loginErr -> {
        System.out.println(loginErr.getMessage());
      });
    }).onFailure(userErr -> {
      System.out.println(userErr.getMessage());
    });
  }
}
........................

Solution 2: Using Future.compose method

Used to chain multiple callbacks in more readable way.
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackHellSoultion.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
//    getUser().onSuccess(user -> {
//      login(user).onSuccess(status -> {
//        showDashboard(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> System.out.println(err));
//      }).onFailure(loginErr -> {
//        System.out.println(loginErr.getMessage());
//      });
//    }).onFailure(userErr -> {
//      System.out.println(userErr.getMessage());
//    });

//    //solution 2: Using Future.compose method
    getUser().compose(user -> {
      return login(user);
    }).compose(status -> {
      return showDashboard(status);
    }).onSuccess(res -> {
      System.out.println(res);
    }).onFailure(err -> {
      System.out.println(err.getMessage());
    });

  }
}

Compose Refactoring: Using Lambdas

//Solution 2.1: Using Future.compose method lambda refactoring.

    getUser()
      .compose(user -> login(user))
      .compose(status -> showDashboard(status))
      .onSuccess(res -> {
        System.out.println(res);
      }).onFailure(err -> {
        System.out.println(err.getMessage());
      });

    //Soution 2.2 : Using Future.compose using Method reference
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
..........................
Callback Hell Solution code:
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackHellSoultion.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
//    getUser().onSuccess(user -> {
//      login(user).onSuccess(status -> {
//        showDashboard(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> System.out.println(err));
//      }).onFailure(loginErr -> {
//        System.out.println(loginErr.getMessage());
//      });
//    }).onFailure(userErr -> {
//      System.out.println(userErr.getMessage());
//    });

//    //solution 2: Using Future.compose method
//    getUser().compose(user -> {
//      return login(user);
//    }).compose(status -> {
//      return showDashboard(status);
//    }).onSuccess(res -> {
//      System.out.println(res);
//    }).onFailure(err -> {
//      System.out.println(err.getMessage());
//    });
    //Solution 2.1: Using Future.compose method lambda refactoring.

//    getUser()
//      .compose(user -> login(user))
//      .compose(status -> showDashboard(status))
//      .onSuccess(res -> {
//        System.out.println(res);
//      }).onFailure(err -> {
//        System.out.println(err.getMessage());
//      });
    //Soution 2.2 : Using Future.compose using Method reference
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}
.....................................................................................
			  Advanced Composition: CompositeFuture
....................................................................................

Lets say i have three methods

-startDbServer
-startHttpServer
-startConfigServer

 I need to ensure that my app must be initalized only , all servers are up, if any one server is failed, stop all servers/ dont initialize my app.

Future Coordination:
  Coordination of multiple futures can be achived with Vertx Futures.

Vertx supports concurrent composition(running serveral async operations in parall) and code looks like sequential - chaining async operations...

Syntax:
 CompositeFuture.all(f1,f2,f3,f4,f5,f6)

  -All composition waits until all futures are successfull or any one failed.


 CompositeFuture.any(f1,f2,f3,f4,f5,f6)
    Any one Compostion waits for any one succeedFuture.
   

package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CompositFutureVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CompositFutureVerticle.class.getName());
  }

  //start Db server
  public Future<String> startDbServer() {
    System.out.println("Db Server started");
    return Future.succeededFuture("Db Server is Up");
  }

  //start web server
  public Future<String> startWebServer() {
    System.out.println("Web Server is started");
   // return Future.succeededFuture("WebServer is Up");
    return Future.failedFuture("Failed WebServer startup");
  }

  //config Server
  public Future<String> startConfigServer() {
    System.out.println("Config Server is started");
    return Future.succeededFuture("ConfigServer is Up");
  }

  @Override
  public void start() throws Exception {
    super.start();
    Future<String> dbServer = startDbServer();
    Future<String> webServer = startWebServer();
    Future<String> configServer = startConfigServer();

    CompositeFuture.all(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
        //do something....
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

    System.out.println("...Any...");
    CompositeFuture.any(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
        //do something....
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}
.....................................................................................
				Promises
....................................................................................

Dont confuse futures with promises

if futures are represent the "read side" of an asynchronous result, promises are the "write side".

Promises are inspired from java script largly.

Promises are semantically meaningfull abstraction for handling async result.

Most of the developers confuse with java Futures and Vertx Futures, in order to avoid confusion, promises were introduced.

Promises cant't be processed directly with "OnComplete/OnSuccess" apis

Promises must be converted into Future before processing.

package com.amex.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PromisesVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PromisesVerticle.class.getName());
  }

  //create Promise and encapulte the data and return.
  public Promise<String> getHelloPromise() {
    Promise promise = Promise.promise();
    promise.complete("Hello");
    return promise;

  }

  public Future<String> getHaiPromise() {
    Promise promise = Promise.promise();
    promise.complete("Hai");
    return promise.future();

  }

  @Override
  public void start() throws Exception {
    super.start();
    getHelloPromise().future().onSuccess(System.out::println);
    getHaiPromise().onSuccess(System.out::println);
  }
}
.....................................................................................
			  verticle start and stop method with promises
.....................................................................................

Async Verticle start and stop methods:

sometimes you want to do something in your verticle startup which takes some time and you dont want the verticle to be considered deployed until that happens.
For Eg you might want to start an http server start method and propagate the asyn result of server listen method.

The way to do it is to implement the asynchronous start method (Start with method with Promise Arg)
 This version of the method takes Promise as a parameter. when the method returns verticle will be not considered deployed.

Every verticle will have unique deploymentId, which can be used to undeploy the verticles

package com.amex.promises;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PromiseStartVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PromiseStartVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new GreeterVerticle(), ar -> {
      if (ar.succeeded()) {
        System.out.println(GreeterVerticle.class.getName() + " Deployement Id  " + ar.result());
        startPromise.future().onSuccess(System.out::println); //ensure that this verticle has been successfull
      } else {
        //startPromise.fail("Something went wrong");
      }
    });
  }

  @Override
  public void stop(Promise<Void> stopPromise) throws Exception {
    super.stop(stopPromise);
  }
}
.....................................................................................	
			 Building Non blocking or Async apps
.....................................................................................

in order to build non blocking io apps (network,filesystem) and timers, language or framework/lib/toolkit has to provide basic requirment.

1.Runtime should have faciltity to talk to low level operating system non blocking apis such as "select/poll/epoll-linux, iocp-windows,kqueue-mac,unix".

2.For Application developers , the language or framework/lib/toolkit must provide high level apis in order to communicate low level system calls api - vertx provides high level apis.

3.At runtime level, Runtime must provide threading features to listen for os kernal events. Event loop threads.

4.Program level, we must bind function to handle such events(callbacks)

Vertx non blocking apis:
.......................

1.Timer 
2.File System
3.Http Api
4.Socket api
5.Udp and DataGram 
etc....

Timer:
......

It is common in vertx to want to perform some action after a certain delay or perdically.

Timer is special non blocking api which schdules any task in delayed manner which does not block the current thread.

Task is executed by "CPU" level.

Timer is not part of FileDecriptor table because it is not an IO operation.

Types of timers:
1.one-shot timers
2.Periodic timers.

one-shot Timers:

1.Basic Timer:
package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class OneShotTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", OneShotTimerVerticle.class.getName());
  }

  //simple delay
  public void delay() {
    vertx.setTimer(1000, handler -> {
      System.out.println("I am delayed task");
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("start");
    delay();
    System.out.println("end");
  }
}
....................................................................................

What if i want to return certain result after time out?

package com.amex.async.timers;

import io.vertx.core.*;

public class TimerWithDataVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", TimerWithDataVerticle.class.getName());
  }

  //Data Transfer with Future with delay
  public Future<String> getMessage() {
    return Future.future(ar -> {
      vertx.setTimer(1000, handler -> {
        String response = "Hello!!!";
        ar.complete(response);
      });
    });
  }

  //Data transfer using callbacks pattern
  public void transfer(Handler<AsyncResult<String>> aHandler) {
    vertx.setTimer(2000, timerHandler -> {
      String response = "Hello,How are you!";
      aHandler.handle(Future.succeededFuture(response));
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("start");
    getMessage().onSuccess(System.out::println);
    transfer(aResult -> {
      if (aResult.succeeded()) {
        System.out.println(aResult.result());
      }
    });
    System.out.println("end");
  }
}

Periodic timers:
 Timers keeps which are keep on running...

vertx.setPeriodic(timer,callback)

package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }

  public void tick() {
    vertx.setPeriodic(1000, handler -> {
      System.out.println(Math.random());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    tick();
  }
}

What if i want to stop timers after some time?
setPeriodic() , which returns timerId, which can be used to cancel the timer...
package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }

  public void tick() {
    long timerId = vertx.setPeriodic(1000, handler -> {
      System.out.println(Math.random());
    });
    //cancel the timer after certain time or certain condition
    vertx.setTimer(10000, handler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    tick();
  }
}
........
How to return data from the Periodic timer?

We cant return Future which encapuslate Periodic timer, because once if return future that cant hold next tick...

We have to use always callback pattern.
package com.amex.async.timers;

import io.vertx.core.*;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }


  public void tick() {
    long timerId = vertx.setPeriodic(1000, handler -> {
      System.out.println(Math.random());
    });
    //cancel the timer after certain time or certain condition
    vertx.setTimer(10000, handler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }

  //send data to the caller
  public void poll(Handler<AsyncResult<Double>> aHandler) {
    long timerId = vertx.setPeriodic(1000, handler -> {
      aHandler.handle(Future.succeededFuture(Math.random()));
    });
    //cancel the timer after certain time or certain condition
    vertx.setTimer(10000, handler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //tick();
    poll(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      }
    });
  }
}
.....................................................................................
			   Data Interchange Format - JSON
.....................................................................................
Json is one of the Most popular data interchange format in distributed application.

In order create Json, vertx provides JsonObject,JsonArray
package com.amex.json;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JsonVerticle.class.getName());
  }

  public Future<JsonObject> getUser() {
    Promise promise = Promise.promise();
    JsonObject user = new JsonObject();
    user.put("id", 1);
    user.put("name", "Subramanian");
    user.put("city", "Coimbatore");
    promise.complete(user);
    return promise.future();
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println("Id " + user.getInteger("id"));
      System.out.println("Name " + user.getString("name"));
      System.out.println("City " + user.getString("city"));
      System.out.println(user.encodePrettily());

    });
  }
}
...................................................................................
		 Fulent API/Fluent Patterns
..................................................................................

Insteam of writing multiple lines of code and storing them into multiple variables, we can chain apis, finally we can get output, This is sometimes called as builder pattern, in vertx we call them as fluent pattern.

Normal 
JsonObject user = new JsonObject();
    user.put("id", 1);
    user.put("name", "Subramanian");
    user.put("city", "Coimbatore");

fulent api:
   JsonObject user = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("city", "Coimbatore");
    promise.complete(user);

Nested Json and JSON array:
package com.amex.json;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JsonVerticle.class.getName());
  }

  public Future<JsonObject> getUser() {
    Promise promise = Promise.promise();
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("name", "Subramanian");
//    user.put("city", "Coimbatore");
//    promise.complete(user);

    //fluent way
    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .put("company", new JsonObject().put("name", "American Express"));

    promise.complete(user);

    return promise.future();
  }

  public Future<JsonArray> getUsers() {
    Promise<JsonArray> promise = Promise.promise();
    JsonArray users = new JsonArray()
      .add(new JsonObject()
        .put("id", 1)
        .put("name", "Subramanian")
        .put("city", "Coimbatore")
        .put("company", new JsonObject().put("name", "American Express"))).add(
        new JsonObject()
          .put("id", 2)
          .put("name", "Murugan")
          .put("city", "Coimbatore")
          .put("company", new JsonObject().put("name", "American Express"))
      );
    promise.complete(users);

    return promise.future();
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println("Id " + user.getInteger("id"));
      System.out.println("Name " + user.getString("name"));
      System.out.println("City " + user.getString("city"));
      System.out.println(user.encodePrettily());
    });
    getUsers().onSuccess(users -> {
      System.out.println(users.encodePrettily());
    });
  }
}
.........

Merging:
........
package com.amex.json;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JsonVerticle.class.getName());
  }

  public Future<JsonObject> getUser() {
    Promise promise = Promise.promise();
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("name", "Subramanian");
//    user.put("city", "Coimbatore");
//    promise.complete(user);

    JsonObject skills = new JsonObject()
      .put("skillId", 1)
      .put("skill", new JsonArray()
        .add("Java")
        .add("Vertx")
        .add("Spring Boot")
        .add("Quarkus")
      );

    //fluent way
    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .mergeIn(skills)
      .put("company", new JsonObject().put("name", "American Express"));

    promise.complete(user);

    return promise.future();
  }

  public Future<JsonArray> getUsers() {
    Promise<JsonArray> promise = Promise.promise();
    JsonArray users = new JsonArray()
      .add(new JsonObject()
        .put("id", 1)
        .put("name", "Subramanian")
        .put("city", "Coimbatore")
        .put("company", new JsonObject().put("name", "American Express"))).add(
        new JsonObject()
          .put("id", 2)
          .put("name", "Murugan")
          .put("city", "Coimbatore")
          .put("company", new JsonObject().put("name", "American Express"))
      );
    promise.complete(users);

    return promise.future();
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println("Id " + user.getInteger("id"));
      System.out.println("Name " + user.getString("name"));
      System.out.println("City " + user.getString("city"));
      System.out.println(user.encodePrettily());
    });
    getUsers().onSuccess(users -> {
      System.out.println(users.encodePrettily());
    });
  }
}
.....................................................................................
			Non Blocking Web Applications
.....................................................................................

HTTP server Application:

1.Vertx Provides webserver, you dont need to deploy vertx apps on Tomcat like container.
2.Vertx Webserver is fully non blocking, powered with event loop threads
3.Vertx Webserver is based "Shared Thread Model"

vertx.createHttpServer()...

Steps:
1.create webserver
2.write request handler
3.deploy the code into web server.

Interfaces:
1.HttpServer
2.HttpServerRequest
3.HttpServerResponse

package com.amex.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Handler;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.http.HttpServerResponse;

public class SimpleHttpVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", SimpleHttpVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Server
    HttpServer httpServer = vertx.createHttpServer();

    //Your application code: Request and Response handling
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      response.end("Hello");
    });
    //deploy and start server
    httpServer.listen(3000, httpServerHandler -> {
      if (httpServerHandler.succeeded()) {
        System.out.println("Server is Up @" + httpServerHandler.result().actualPort());
      } else {
        System.out.println("Server start up failed " + httpServerHandler.cause().getMessage());
      }
    });

  }
}
....

Fluent web server:

package com.amex.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.http.HttpServerResponse;

public class FluentWebServer extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FluentWebServer.class.getName());
  }

  private static void handle(HttpServerRequest request) {
    request.response().end("Hello!");
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
//    vertx.createHttpServer()
//      .requestHandler(request -> request.response().end("Hello"))
//      .listen(3000, handler -> {
//        System.out.println("Vertx Server is Running!");
//      });

    vertx.createHttpServer()
      .requestHandler(FluentWebServer::handle)
      .listen(3000, handler -> {
        System.out.println("Vertx Server is Running!");
      });
  }
}
.....................................................................................
			  Micro services API development
.....................................................................................

What is API?
  Application programming interface

In any software, data is center point, programs talks each other in order to exchange data.

How data is exchanged among or between programs?

 Every program expose "method/function/procedure" to exchange data.
 "method/function/procedure" is generally called as "API".

 Now a days most of programming languages uses "object oriented model" to design apis

 Object represents collection of "api". Object encapuslate apis....
 
 Object technically called as "End Point".

Types of api based on accessability:

1.Local api
   apis are communciated within single runtime eg witin single jvm/webserver
2.Remote api
  apis are commmunicated outside runtime via networks using network protocals.

When we think about distributed computing so called Microservices, apis are exposed via network only.

RPI: (Remote P
rocedure Invocation).

We have RPI lot of RPI technology...(api developement)

1.Web services -HTTP 1.1
   REST
   SOAP
   GRAPHQL

2.RPC
   CORBA
   RMI
   DCOM
   EJB
   GRPC - Modern RPC Framework -HTTP 2/TCP
   Websocket -WS

3.MOM 
   JMS
   Kakfa
   RabbitMQ
   IBMMQ

How to build REST API?

Resource  - Domain Model which is represented by Object having apis
Resource identifier -URI  ="/api"
Resource Method - GET,POST,PUT,DELETE - API verbs

package com.amex.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;

public class SimpleHTTPApi extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", SimpleHTTPApi.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.createHttpServer().requestHandler(request -> {
      //building rest api -  url and method
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
        request.response().setStatusCode(200).end("USERS Get");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
        request.response().setStatusCode(200).end("USERS Post");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
        request.response().setStatusCode(200).end("USERS Put");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.DELETE) {
        request.response().setStatusCode(200).end("USERS DELETE");
      }
    }).listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is Running");
      } else {
        System.out.println("Server start up failed");
      }
    });
  }
}

in order to build rest api we need url and method for each resource, in the above code, we have verified method and url.

The develper has to write all method and resource mapping logic..
There is no proper  modularity in building apps

Soultion:
 Vertx provides a small framework/module for abstracting these things vertx-web

Vertx-Web:

Vertx-core provides a fairly low level set of functionality for handling http.
Vertx web builds on the top of vertx-core to provide a richer set of functionality for building real web applications more easily.

Vertx web is a greate fit for writing RESTfull Http microservices 


Features of Vertx-Web:
.......................

1.Routing (based on method,path,etc)
2.Regular expression based pattern matching for paths
3.Extract path parameters from paths.
4.Content negotiation
5.Request body handling
6.Multi part file uploads
7.Sub Routers
8.Session Support
9.CORS handling
10.Error Page handling
11.Authentication and authorization using jwt,http,oauth2
12.Template supports
etc...


Vertx Web Core Features:

1.Router:
  Router is one of the core concepts vertx-web
  It is object which maintains zero or more routes("url mappers")
  Router takes an http request and finds the matching routing for that request
  Every route has handler which process requests and send response

2.RoutingContext
   It is container object from which you can get Request and Response Objects

Basic routing:
package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class SimpleWebAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", SimpleWebAPI.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //route handler: Request handler
    router.route().handler(ctx -> {
      HttpServerResponse response = ctx.response();
      response.setStatusCode(200);
      response.putHeader("content-type", "application/json");
      JsonObject jsonObject = new JsonObject().put("message", "Hello Vertx");
      response.end(jsonObject.encodePrettily());
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!");
      }
    });

  }
}
....................................................................................

Routers:

 URL mapping

Router router = Router.router(vertx);

1.router.route(HTTPMethod.GET,"url").handler(ctx->{})
2.router.get("url").handler | router.post("url").handler ...


package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class URLMapperWeb extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", URLMapperWeb.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.post("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}
.....................................................................................				How to read Payload
.....................................................................................

ctx.getBodyAsJson () method is used to read payload.

package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class RequestPayload extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", RequestPayload.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.post("/api/users").handler(ctx -> {
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}

After running this code , you will get error? or you will will get null?

in order to read json we need to set json parser (middlewares)

middlewares are just code , get initalized before route is handled.

There is middleware called BodyHandler middleware.
package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class RequestPayload extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", RequestPayload.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //initialize the middleware
    //here we apply middleware for all router
    router.route().handler(BodyHandler.create());

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.post("/api/users").handler(ctx -> {
      //current vertx deprecated this api
      //JsonObject payload = ctx.getBodyAsJson();
      //lastest vertx api body
      JsonObject payload = ctx.body().asJsonObject();
      System.out.println(payload);
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}
.....................................................................................
			 Parameters 

1.Path Parameters
2.Query Parameters

Path Parameters:

Router router = Router.router(vertx);
router.get('/api/users/:id').handler(ctx)
String param = ctx.pathParam("id")

package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class PathParameter extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PathParameter.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //initialize the middleware
    //here we apply middleware for all router
    router.route().handler(BodyHandler.create());

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.get("/api/users/:id").handler(ctx -> {
      String id = ctx.pathParam("id");
      ctx.response().setStatusCode(200).end("USERS -GET" + id);
    });

    router.post("/api/users").handler(ctx -> {
      //current vertx deprecated this api
      //JsonObject payload = ctx.getBodyAsJson();
      //lastest vertx api body
      JsonObject payload = ctx.body().asJsonObject();
      System.out.println(payload);
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}
....................................................................................
			  Query Parameters

Router router = Router.router(vertx);
router.get('/api/users/:id').handler(ctx)
String param = ctx.queryParameter("id")
package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

import java.util.List;

public class QueryParameter extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", QueryParameter.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //initialize the middleware
    //here we apply middleware for all router
    router.route().handler(BodyHandler.create());

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.get("/api/users/location").handler(ctx -> {
      System.out.println("location");
      List<String> city = ctx.queryParam("city");
      System.out.println(city);
      city.forEach(System.out::println);
      ctx.response().setStatusCode(200).end("USERS -GET");
    });
    router.get("/api/users/:id").handler(ctx -> {
      String id = ctx.pathParam("id");
      ctx.response().setStatusCode(200).end("USERS -GET" + id);
    });

    router.post("/api/users").handler(ctx -> {
      //current vertx deprecated this api
      //JsonObject payload = ctx.getBodyAsJson();
      //lastest vertx api body
      JsonObject payload = ctx.body().asJsonObject();
      System.out.println(payload);
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}
....................................................................................
			  Resource oriented Routers
....................................................................................

Domain models

api/users
api/products
api/customers
api/items

What if i have more resources and more routes?

ProductRouter ---- /api/products
UserRouter -----/api/users
PaymentRouter ---/api/payments

if you have more than one router , how to bind with request handler

 httpServer.requestHandler(?);

SubRouters and MainRouters

-You can have more subRouters - products,users etc..
-You can have only one main or app router- appRouter
-requestHandler takes appRouter
->Inside App Router we have to configure subrouters
 
How to bind /mount/connect app router with subrouter?

Router router = Router.router(vertx);

router.mountSubRouter() - old one

appRouter.route("/api/users/*").subRouter(userRouter) ; - new One

Rules:
1.The route path must end with a wild card "/*"
2.Parameters are allowed but full regex pattern not
3.Only one handler can be registered.
2.Only one router per path object

Full code:
package com.amex.http.web.subrouters;

import com.amex.http.web.PathParameter;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class ResourceRouters extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ResourceRouters.class.getName());
  }

  //router class : inner classes
  private static class UserRouter {
    //CURD operations
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.body().asJsonObject();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("User saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("User List");
    }
  }

  private static class ProductRouter {
    //CURD operations
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.body().asJsonObject();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("Product saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("Product List");
    }
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();
    //Request handling logic will be inside router
    //create sub routers
    Router userRouter = Router.router(vertx);
    Router productRouter = Router.router(vertx);
    Router customerRouter = Router.router(vertx);
    //appRouter
    Router appRouter = Router.router(vertx);
    //initialize the middleware
    //here we apply middleware for all router
    appRouter.route().handler(BodyHandler.create());


    //URL Patterns
    //http://localhost:3000/api/users/list
    userRouter.get("/list").handler(UserRouter::list);
    userRouter.post("/save").handler(UserRouter::create);

    //Products
    productRouter.get("/list").handler(ProductRouter::list);
    productRouter.post("/save").handler(ProductRouter::create);


    //appRouter with subRouter binding
    //old api: depricated api
//     appRouter.mountSubRouter("/api/users", userRouter);
    //new api
    appRouter.route("/api/users/*").subRouter(userRouter);
    //appRouter.mountSubRouter("/api/products", productRouter);
    appRouter.route("/api/products/*").subRouter(productRouter);

    //assign router to request handler
    httpServer.requestHandler(appRouter);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      } else {

      }
    });

  }
}
....................................................................................
			  Exception Handling
.....................................................................................

if some thing went wront how to handle exception and how to send error message to clients.

router.failureHandler(handler->{
   send error data to client and tools
})

package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class ExceptionHandlingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ExceptionHandlingVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router userRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);
    HttpServer httpServer = vertx.createHttpServer();

    appRouter.route("/api/users/*").subRouter(userRouter);


    userRouter.get("/list/:name").handler(ctx -> {
      String name = ctx.pathParam("name");
      if (name.equals("admin")) {
        ctx.response().end("You are valid user");
      } else {
        throw new RuntimeException("invalid user");
      }
    }).failureHandler(ctx -> {
      int statusCode = ctx.statusCode();
      String message = ctx.failure().getMessage();
      JsonObject errorMessages = new JsonObject().put("code", statusCode).put("message", message);
      ctx.response().setStatusCode(statusCode).end(errorMessages.encodePrettily());
    });
    //assign router to request handler
    httpServer.requestHandler(appRouter);
    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      } else {

      }
    });
  }
}

Handlers Types:

1.router.handler() - async request handling
2.router.failureHandler() - async exception /error handler

Global Handlers
BodyHandler -  Converts jsonString to jsonObject
TimeoutHandler  - to Request timeout for given url or global
blockingHandlier - for writing blocking code...
....................................................................................
			 Vertx  and Datasources
.....................................................................................

Vertx supports nonblocking database access..
Vertx Provides nonblocking drivers to communicate with relational and nosql databases..

1.JDBC Client
2.PostgreSQL
3.MySQL
4.DB2
5.Mongodb
6.Redis
7.Cassandra 

JDBC Client:

=>JDBC is a technolgy through which you can talk to relational database.
=>As of now JPA ,hibernate ORM is not supported by vertx.
=>JDBC code you can write in two ways callback pattern, reactive patterns

in order to write database code we have two apis

1.JDBCClient - Legacy , you can avoid 
2.SqlClient API 
   Sql is abstraction api which provides easy way of querying data from databases
  JdbcPool Instance to perform SQL operations - INSERT,DELETE,UPDATE,SELECT
  You can write preparedStatements and callable statements.

1.jdbc dependency
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-jdbc-client</artifactId>
    </dependency>

database driver dependency

<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <version>2.3.2</version>
 </dependency>



2.Configuring connections
   JsonObject connectionInfo = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");

 JDBCClient client= JDBCClient.createShared(vertx, connectionInfo);

3.You have to use callback chain pattern.
    connection success
            |
            do sql operations
   else 
    throw erro
   client.getConnection(connection->{
        if(connection.succeeded(){

         }
   })
			
3.Get sqlConnection instance

 client.getConnection(connection->{
        if(connection.succeeded(){
	final SQLConnecton con=connection.result()
         }
   })

4. You can execute Query

 client.getConnection(connection->{
        if(connection.succeeded(){
	final SQLConnecton con=connection.result()
	  con.execute(sql,handler())
         }
   })

Callback Based JDBC code using JDBCClient API
package com.amex.http.jdbc;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import jdk.jshell.ImportSnippet;

public class JDBCVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JDBCVerticle.class.getName());
  }

  public void prepareDatabase() {
    JsonObject connectionInfo = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");

    JDBCClient jdbcClient = JDBCClient.createShared(vertx, connectionInfo);
    jdbcClient.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("connection success");
        SQLConnection sqlConnection = connection.result();
        //table creation
        String CREATE_TABLE = "CREATE TABLE user(id int primary key, name varchar(255))";
        sqlConnection.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.succeeded()) {
            System.out.println("table is created");
            String INSERT_QUERY = "INSERT INTO user VALUES(1,'subramanian')";
            sqlConnection.execute(INSERT_QUERY, tableInsert -> {
              if (tableInsert.failed()) {
                System.out.println(tableInsert.cause().getMessage());
              } else {
                String SELECT_QUERY = "SELECT * FROM user";
                sqlConnection.query(SELECT_QUERY, tableSelect -> {
                  System.out.println(tableSelect.result().getResults());
                });	
              }
            });
          } else {
            System.out.println("Table not created" + tableCreate.cause().getMessage());
          }
        });
      } else {
        System.out.println("Connection failed" + connection.cause().getMessage());
      }
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    prepareDatabase();
  }
}
......................................................................................

JdbPool:
    JsonObject config = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");
    //Pool is ready
    JDBCPool pool = JDBCPool.pool(vertx, config);

Query Operations:CREATE,INSERT,SELECT,UPDATE,DELETE

pool.query(QUERY)
.execute()
.onFailure()
.onSuccess(rows->{})

pool.preparedQuery("query")
  .execute(Tuple.of(value))
  .onFailure()
  .onSuccess()

package com.amex.http.jdbc;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.Row;

public class JDBCPoolVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JDBCPoolVerticle.class.getName());
  }

  public void prepareDb() {
    JsonObject config = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");
    //Pool is ready
    JDBCPool pool = JDBCPool.pool(vertx, config);
    //create,insert,select
    pool
      .query("create table test(id int primary key,name varchar(255))")
      .execute()
      .compose(r ->
        pool.query("insert into test values(1,'subramanian'),(2,'murugan')").execute()
      ).compose(r -> pool.query("select * from test").execute())
      .onSuccess(rows -> {
        for (Row row : rows) {
          System.out.println(row.toJson());
        }
      }).onFailure(System.out::println);

  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    prepareDb();
  }
}
...................

Use case : 
CREATE REST API FOR "Products" 
Product id, product name, product price, product qty

Req:
Web
 /api/products - list all products
 /api/products/id - get one product
 /api/products -  save
 /api/products  - update
 /api/products  - remove

JDBC layer - H2 db, jdbc Pool
.....................................................................................
		   Microservices - Service Communications
.....................................................................................

Communication patterns:
1.with in process (within JVM) (Within Vertx Engine)
2.Across Process (Across JVM) (Across Vertx Engine) - Clustered Vertx

Communication styles:
 Communication between two services can be sync or async.
 Vertx is based on async communication

Communcations implementation

1.HTTP Based communication 
   WebClient api
2.Actor Model communication
  Event Bus

Event Bus:
-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer

How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern

Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model   "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon

How to create Event Bus Object?

 EventBus eb = vertx.eventBus();

 //send message - publisher
    pub-sub
    point-point
    request-reply

 //listen message -listener

  eb.consumer('address',handler->{})
....................................................................................
			PUB-SUB
.....................................................................................

One Publisher and Many Subscriber.

if one publisher publishes messages, many subscribers get the same message at same time.
package com.amex.distributed.eventbus.pubsub;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

//Address
class Address {
  public static String PUB_SUB_ADDRESS = "news.in.covid";
}
//Publisher Verticle

//publisher publish news to all news tv channels
class PublisherVerticle extends AbstractVerticle {
//  EventBus eventBus = vertx.eventBus();

  public void publish() {
    //Get EventBus Object reference
    EventBus eventBus = vertx.eventBus();
    String message = "Last 24 Hrs covid count is 80000";
    //send message with timer
//    vertx.setTimer(1000, ar -> {
//      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
//    });
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //route handler: Request handler
    router.route().handler(ctx -> {
      HttpServerResponse response = ctx.response();
      response.setStatusCode(200);
      eventBus.publish(Address.PUB_SUB_ADDRESS, message);
      response.end(message + "has been published");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!");
      }
    });

  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    publish();
  }
}

//subscribers
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUB_SUB_ADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    consume();
  }
}


//Subscriber verticles

public class PubSubVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PubSubVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new PublisherVerticle());
    vertx.deployVerticle(new NewsSevenVerticle());
    vertx.deployVerticle(new BBCVerticle());
    vertx.deployVerticle(new NDTVVerticle());
  }
}
.....................................................................................
			 Point To Point
.....................................................................................
One to One 
package com.amex.distributed.eventbus.pointtopoint;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;


class Address {
  public static String POINT_TO_POINT = "covid.fin.request";
}

//publisher
class FinanceRequestVerticle extends AbstractVerticle {
  public void requestFinance() {
    System.out.println("Finance Request started....");
    vertx.setTimer(5000, ar -> {
      //point to point : send method
      String message = "Dear Team, We request that we want 1 Billion $  for Covid recovery fund";
      //point to point ; send
      vertx.eventBus().send(Address.POINT_TO_POINT, message);
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    requestFinance();
  }
}

//consumer

class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINT_TO_POINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request   : " + news.body());
    });
  }


  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    consume();
  }
}


public class PointToPointVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PointToPointVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new FinanceRequestVerticle());
    vertx.deployVerticle(new CenertalFinanceVerticle());

  }
}
.....................................................................................
			 Request-Reply
....................................................................................

One to One with Ack.
package com.amex.distributed.eventbus.requestreply;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;


class Address {
  public static String REQUEST_REPLY = "covid.lab.report";
}


class ReportVerticle extends AbstractVerticle {

  public void sendReport() {
    vertx.setTimer(5000, ar -> {
      String message = "Report of Mr.x";
      vertx.eventBus().request(Address.REQUEST_REPLY, message, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
        } else {
          System.out.println(asyncResult.cause());
        }
      });
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    sendReport();
  }
}

class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUEST_REPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply("Patient is Critical, Need More attention");
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    consume();
  }
}


public class RequestReplyVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", RequestReplyVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new ReportVerticle());
    vertx.deployVerticle(new LabVerticle());
  }
}
...................................................................................
		 HTTP Communication - WebClient
...................................................................................
Vertx-WebClient:
................

Verx-Web Client is async http 1.1 and HTTP/2 Client.

 <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web-client</artifactId>
 </dependency>
How to begin?

Create webclient object.

WebClient client = WebClient.create(vertx);
If you want to pass any configuration

WebClientOptions options=new WebClientOptions().setKeepAlive(true);

WebClient client = WebClient.create(vertx,options);


How to requests without any body.

client.get(port,url,"uri").send().onSuccess().onFailure()


package com.amex.distributed.webclient;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.HttpRequest;
import io.vertx.ext.web.client.WebClient;
import io.vertx.ext.web.handler.BodyHandler;

class HelloVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());

    router.get("/api/hello").handler(ctx -> {
      ctx.response().end("Hello");
    });
    vertx.createHttpServer().requestHandler(router).listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Provider Server is running");
      }
    });

  }
}

class GreeterVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());
    WebClient webClient = WebClient.create(vertx);
    router.get("/api/greet").handler(ctx -> {
      //communicate with HelloRest verticle
      HttpRequest<Buffer> httpRequest = webClient.get(3000, "localhost", "/api/hello");
      httpRequest.send().onSuccess(response -> {
        ctx.response().end(response.body().toString());
      });
    });
    router.get("/api/posts").handler(ctx -> {
      HttpRequest<Buffer> httpRequest = webClient.
        getAbs("https://jsonplaceholder.typicode.com/posts");
      httpRequest.send().onSuccess(posts -> {
        ctx.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(posts.bodyAsJsonArray().encodePrettily());
      }).onFailure(err -> {
      });
    });
    vertx.createHttpServer().requestHandler(router).listen(3001, handler -> {
      if (handler.succeeded()) {
        System.out.println("Consumer Server is running");
      }
    });

  }
}

public class WebClientVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", WebClientVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new HelloVerticle());
    vertx.deployVerticle(new GreeterVerticle());
  }
}
.....................................................................................
			Vertx  Threading Model
....................................................................................
Vertx Threading Models:
.......................

Vertx provides basically provides two types threads

1.Non blocking threads called "event loop threads"
   These are used to run non blocking io opertions
   By default the vertx uses per cpu core 2 threads.
   Works are distributed among threads based on "round robin algorthim".

2.Woker Pool threads
    In vertx what if i want to write some blocking code.
  Thsese threads can be used.


What can be a blocking code?

-Thread.sleep
-long running task
-legacy database calls like hibernate/jpa calls
-legacy network calls
etc....

What if i write blocking code with in nonblocking context..if you try to run blocking code within event loop thread.

Every Verticle by default is bound with "Event Loop thread".

Use case 1: How to get event loop thread information.
package com.amex.threading;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class EventLoopThreadInfo extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", EventLoopThreadInfo.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("Current Thread + " + Thread.currentThread().getName());
  }
}

output:
Current Thread + vert.x-eventloop-thread-1
....................................................................................
			 Round Robin and Event loop threads
....................................................................................

package com.amex.threading;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

class HelloVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(HelloVerticle.class.getName() + " is  Running on " + Thread.currentThread().getName());
  }
}

public class RoundRobinThreadInfo extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", RoundRobinThreadInfo.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("Current Thread + " + Thread.currentThread().getName());
    for (int i = 0; i < 27; i++) {
      vertx.deployVerticle(new HelloVerticle());
    }
  }
}

outPut:
Current Thread + vert.x-eventloop-thread-1
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-7
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-8
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-4
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-19
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-5
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-17
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-15
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-14
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-11
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-12
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-3
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-0
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-23
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-20
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-6
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-16
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-18
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-21
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-10
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-9
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-13
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-22
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-2
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-4
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-1
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-3
com.amex.threading.HelloVerticle is  Running on vert.x-eventloop-thread-2

.....................................................................................
			Use case 2: Blocking and Nonblocking threads
....................................................................................

Thread.sleep :
..............
package com.amex.threading.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

class HelloVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Thread sleep is going to block thread
    System.out.println("Hello Verticle is Running  " + Thread.currentThread().getName());
    Thread.sleep(1000);
    System.out.println("Hello, I am delayed Message");
  }
}

public class BlockingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", BlockingVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("Main Thread + " + Thread.currentThread().getName());
    vertx.deployVerticle(new HelloVerticle());

  }
}

Output:
Main Thread + vert.x-eventloop-thread-1
Hello Verticle is Running  vert.x-eventloop-thread-2
Oct 19, 2023 12:13:38 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
Hello, I am delayed Message

Now i increase the time.


import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

class HelloVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Thread sleep is going to block thread
    System.out.println("Hello Verticle is Running  " + Thread.currentThread().getName());
    Thread.sleep(5000);
    System.out.println("Hello, I am delayed Message");
  }
}

public class BlockingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", BlockingVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("Main Thread + " + Thread.currentThread().getName());
    vertx.deployVerticle(new HelloVerticle());

  }
}

Main Thread + vert.x-eventloop-thread-1
Hello Verticle is Running  vert.x-eventloop-thread-2
Oct 19, 2023 12:14:07 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
Oct 19, 2023 12:14:10 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 2791 ms, time limit is 2000 ms
Oct 19, 2023 12:14:11 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 3794 ms, time limit is 2000 ms
Oct 19, 2023 12:14:12 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 4795 ms, time limit is 2000 ms
Hello, I am delayed Message

Still increase Time;
Main Thread + vert.x-eventloop-thread-1
Hello Verticle is Running  vert.x-eventloop-thread-2
Oct 19, 2023 12:15:25 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
Oct 19, 2023 12:15:28 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 2795 ms, time limit is 2000 ms
Oct 19, 2023 12:15:29 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 3795 ms, time limit is 2000 ms
Oct 19, 2023 12:15:30 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 4796 ms, time limit is 2000 ms
Oct 19, 2023 12:15:31 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-2,5,main] has been blocked for 5797 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.base@17.0.7/java.lang.Thread.sleep(Native Method)
	at app//com.amex.threading.blocking.HelloVerticle.start(BlockingVerticle.java:13)
	at app//io.vertx.core.impl.DeploymentManager.lambda$doDeploy$5(DeploymentManager.java:195)
	at app//io.vertx.core.impl.DeploymentManager$$Lambda$112/0x0000000800cbfa08.handle(Unknown Source)
	at app//io.vertx.core.impl.ContextInternal.dispatch(ContextInternal.java:277)


Now you cant block any event loop thread beyond 2000ms which is default timeout. if you do so, it gives warning first, then throws Exception VertxException(Thread Blocked)


What if i want to run blocking code within the context of non blocking?


There are two types of solution

1.Convert the Eventloop thread verticles into "Worker Verticle".
2.I dont want the entire verticle to be part of "Worker Verticle Threads", i want only few apis/code to be isloated into separte worker pool thread.


Types of Verticles:

1.Standard Verticle
   Verticles are executed by event loop threads, which is normal and regular verticles
2.Worker Verticle
   Verticles are special executed by separate threadof execution called "worker pool threads"


How to create worker verticle?

in order to create worker verticle, we need to understand "Vertx Configuration System"

In Vertx We have so many Configuration Objects

1.HTTP
   HttpServerOptions

 HttpServerOptions serverOptions = new HttpServerOptions().setPort(3000).setHost("localhost");
 HttpServer createHttpServer(serverOptions);

2.Event Bus
  DeliverOptions options = new DeliveryOptions().addHeader("myheader","value")
   vertx.eventBus().send("hello",options);

3.Verticle Configuration
   DeployementOptions options = new DeploymentOptions().setWorker(true)
   vertx.deployVerticle("verticle",options)   

4.Vertx Configuration
   Vertx engine configuration
  VertxOptions


Worker Verticle:
package com.amex.threading.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

class DelayVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(DelayVerticle.class.getName() + " is running on " + Thread.currentThread().getName());
    try {
      Thread.sleep(10000);
      System.out.println("I am delayed Message");
    } catch (Exception e) {

    }
  }
}

public class WorkerVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", WorkerVerticleMain.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //worker Verticle
    DeploymentOptions options = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new DelayVerticle(), options);
  }
}
..........................................................................................
			 Method running within Blocking Context

package com.amex.threading.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

class DelayVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(DelayVerticle.class.getName() + " is running on " + Thread.currentThread().getName());
    try {
      Thread.sleep(10000);
      System.out.println("I am delayed Message");
    } catch (Exception e) {

    }
  }
}

class GreeterVerticle extends AbstractVerticle {

  //run only this code in a separate thread of execution
  private void sayHello(Promise<Void> promise) {
    try {
      System.out.println("sayHello method " + " is running on " + Thread.currentThread().getName());

      Thread.sleep(10000);
      System.out.println("Hello from sayHello");
      promise.complete();
    } catch (Exception e) {
      promise.fail("something went wrong");
    }
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is running on " + Thread.currentThread().getName());
    vertx.executeBlocking(this::sayHello);
  }
}

public class WorkerVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", WorkerVerticleMain.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //worker Verticle
    DeploymentOptions options = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new DelayVerticle(), options);
    vertx.deployVerticle(new GreeterVerticle());

  }
}
.............................................................................................
		How to exchange data between Blocking and nonblocking
			 How to write router and blocking code.

router.handler() - non blocking router
router.blockingHandler - blocking router means that you write/invoke blocking code.

Note:
 Dont Block Event Loop thread if you do so, you will not get the benefit of Nonblocking arch...

package com.amex.threading.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

class DelayVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(DelayVerticle.class.getName() + " is running on " + Thread.currentThread().getName());
    try {
      Thread.sleep(10000);
      System.out.println("I am delayed Message");
    } catch (Exception e) {

    }
  }
}

class GreeterVerticle extends AbstractVerticle {

  //run only this code in a separate thread of execution
  private void sayHello(Promise<Void> promise) {
    try {
      System.out.println("sayHello method " + " is running on " + Thread.currentThread().getName());

      Thread.sleep(10000);
      System.out.println("Hello from sayHello");
      promise.complete();
    } catch (Exception e) {
      promise.fail("something went wrong");
    }
  }

  public void findAll(Promise<JsonObject> promise) {
    System.out.println("findAll is running " + Thread.currentThread().getName());
    try {
      Thread.sleep(5000);
      promise.complete(new JsonObject().put("message", "Hello"));
    } catch (Exception es) {
    }
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println(GreeterVerticle.class.getName() + " is running on " + Thread.currentThread().getName());
    vertx.executeBlocking(this::sayHello);
    vertx.executeBlocking(this::findAll).onSuccess(res -> {
      System.out.println("Got " + res.encodePrettily());
    });
    //get data from the blocking api
    //router with blocking :
    Router router = Router.router(vertx);
    //
    router.get("/api/blocking").blockingHandler(rc -> {
      System.out.println("findAll is running " + Thread.currentThread().getName());
      try {
        Thread.sleep(5000);
        rc.response().end(new JsonObject().put("message", "Hello").encodePrettily());
      } catch (Exception es) {
      }
    });
    vertx.createHttpServer().requestHandler(router).listen(3000, ar -> {
      if (ar.succeeded()) {
        System.out.println("Server is Running");
      }
    });

    vertx.createHttpServer().requestHandler(router).listen(3000, ar -> {
      if (ar.succeeded()) {
        System.out.println("Server is Running");
      }
    });
  }
}

public class WorkerVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", WorkerVerticleMain.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //worker Verticle
    DeploymentOptions options = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new DelayVerticle(), options);
    vertx.deployVerticle(new GreeterVerticle());

  }
}
.............................................................................................
			 Microservices  - Configuration
............................................................................................

Vertx-Configuration
 The vertx-config module provides configuration stores through which you can store application settings.

Concepts:

Configuration Storage:
......................

 Where the config information stored.

1.Files
2.Directories- ldap
3.http servers 
4.Redis
5.System Properties
6.enviroment properties
7.InMemory -Part of the application.


Steps:
1.    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-config</artifactId>
    </dependency>

2.ConfigRetriever Object holds Configuration information.
 ConfigRetriever retriver = ConfigRetriever.create(vertx);

By default ConfigRetriver is going load config data from the following order

1.The Vertx verticle config() - 1
2.The system properties  -2
3.Environment variables - 3
4.conf/config.json - 4

Configuration information is available as json.

It supports config file formats like yaml, json,properties

Verticle 
  -can read config data from vertx context object/deployment options
  -can read config data from the file via command line args
  -can read from any storage via vertx-config module 


Use case : verticles and configuration.

package com.amex.config;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //get config data
    JsonObject config = config();
    String message = config.getString("message", "default");
    int port = config.getInteger("port", 8080);
    vertx.createHttpServer().requestHandler(re -> {
      re.response().end(message);
    }).listen(port);

  }
}

public class ConfigMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ConfigMainVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //config object
    JsonObject config = new JsonObject().put("message", "Hello Config").put("port", 3000);
    DeploymentOptions options = new DeploymentOptions().setConfig(config);
    vertx.deployVerticle(new GreeterVerticle(), options);
  }
}
.............................................................................................
			Config from the Configuration system
.............................................................................................

How to read configuration from external configuration system.
 
Configuration system could be file,dir,git......


1.ConfigRetriever:

  It configures a set of configuration store, where Configuration store defines  a location 
  from where the configuration data is read and also format(JSON by default).

 The Result from ConfigRetriever is JSON object.

Flow

  Application ------------------|ConfigRetriver----||ConfigStore
				JSON Object	<----	


How to instantiate the ConfigRetriver:

 ConfigRetriver retriver = ConfigRetriver.create(vertx).

Steps:

1.Add Dependency.

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-config</artifactId>
</dependency>

2.create resources/conf/config.json file

{
  "appname": "Vertx Application",
  "version": "1.0.0"
}

3.set storage options
   ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));

4.Create ConfigReteriver

    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));
retriever.getConfig().onComplete()

eg:
package com.amex.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //get config data
    JsonObject config = config();
    String message = config.getString("message", "default");
    int port = config.getInteger("port", 8080);
    vertx.createHttpServer().requestHandler(re -> {
      re.response().end(message);
    }).listen(port);

  }
}

class ConfigFileRetriverVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    //Store Configuration
    ConfigStoreOptions fileStoreOptions = new ConfigStoreOptions();
    fileStoreOptions.setType("file");
    fileStoreOptions.setFormat("json");
    fileStoreOptions.setConfig(new JsonObject().put("path", "conf/config.json"));

    //Retriver Otions
    ConfigRetrieverOptions configRetrieverOptions = new ConfigRetrieverOptions().addStore(fileStoreOptions);

    //ConfigRetriver
    ConfigRetriever retriever = ConfigRetriever.create(vertx, configRetrieverOptions);

    retriever.getConfig().onSuccess(config -> {
      System.out.println(config.encodePrettily());
      vertx.createHttpServer().requestHandler(res -> {
        res.response().end(config.encodePrettily());
      }).listen(config.getInteger("port", 3003));
    }).onFailure(err -> {
      System.out.println(err.getMessage());
    });
  }
}

public class ConfigMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ConfigMainVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //config object
    JsonObject config = new JsonObject().put("message", "Hello Config").put("port", 3000);
    DeploymentOptions options = new DeploymentOptions().setConfig(config);
    vertx.deployVerticle(new GreeterVerticle(), options);
    vertx.deployVerticle(new ConfigFileRetriverVerticle());
  }
}
..............................................................................................
			 Microservices -Service Discovery and Registry
.............................................................................................
What is service?
 Object

What is registry?
 Centeralized database

What is database?
 We store something and later we reterive.

What is discovery?
  Discovery is nothing but "lookup/search" something from the registry.

Why Service Registry?

  "Keeping Global shared information" across the distributed apps(micro service apps)


Service Registry stores "Resources" so that other services in the application can access.



What we can store inside Registry Server in vertx?

 Resources:

Types of Resources(Services):
.............................

The services you can register into registry

HTTP Endpoint -HttpEndPoint.createRecord
Event Bus Service -EventBus.createRecord
Message Source
JDBC Data Source
Redis Data Source
MongoDb Data Source


How to store resources into Service Registry in vertx

1.Record - bag - inside bag you can store any resource-store that record into registry server.

Vertx Resource Storage:

Vertx resources are stored in side registry by packing resouces into a object called "Record".


Implementation:

What you need?

1.Registry server- where you can store all shared resources(httpendpoint,jdbcconnection,eventbus...)

Vertx provides default built in Registry Server:
...............................................
-Key value data structure;
  Map- implementations.

Popular Registry Servers:
.........................
1.eureka server
2.Apache zoo keeper
3.Consule
4.Kubernetes
5.Redis
etc....

Resource--->Record 

Service Discovery Objects:

1.Record
2.Service
3.ServiceDiscovery

Vertx has ServiceDiscovery Instance, which helps to publish / un publish ,and discover
services 


Publishing HTTP End Point into Registry, where other verticles can consume that.

Use case : HTTPEndPoint

Steps:

...............................
1.create Record

2.wrap the resources into Record

3.Publish it


...............................
4.Get Record

5.Get Reference from the Record

6.Unpublish it if you dont need

7.Use the Resource(service)


Add dependency:

  <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-service-discovery</artifactId>
    </dependency>



package com.amex.distributed.serviceregistry;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.WebClient;
import io.vertx.servicediscovery.Record;
import io.vertx.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.types.HttpEndpoint;

class GreeterRestVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);

    router.get("/api/hello").handler(rc -> {
      rc.response().end("Hello,Service Discovery and Registry");
    });
    vertx.createHttpServer().requestHandler(router).listen(3000);
  }
}

//Consumer Verticle , which communicates GreeterRestVerticle via WebClient not directly but via
//Service Registry.
class ConsumerVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Service Communication via Service Discovery
    ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    //enable discovery server
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);

    Router router = Router.router(vertx);

    router.get("/api/greet").handler(rc -> {
      //Communicate Service Registry and get Record,Get Reference.
      HttpEndpoint.getWebClient(discovery, new JsonObject().put("name", "greeterApiRecord"), ar -> {
        //Get Reference from the Record
        WebClient webClient = ar.result();
        //do your job with Resource
        webClient.get("/api/hello").send(result -> {
          System.out.println("Response is ready!");
          rc.response().end(result.result().bodyAsString());
        });
        rc.response().endHandler(ar1 -> {
          //remove /release discovery record
          ServiceDiscovery.releaseServiceObject(discovery, webClient);
        });
      });

    });
    vertx.createHttpServer().requestHandler(router).listen(8080);


  }
}


//Publisher Verticle publishes
class PublisherVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Service Registry Server configuration
    ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    //Service Registry instance
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);

    //Create Record
    Record record = HttpEndpoint.createRecord("greeterApiRecord", "localhost", 3000, "/api/hello");

    //publish the Record
    //Publish the Record
    discovery.publish(record, ar -> {
      if (ar.succeeded()) {
        System.out.println("Successfully published >>>>" + ar.result().toJson());
      } else {
        System.out.println(" Not Published " + ar.cause());
      }
    });
  }
}


public class ServiceRegistryAndDiscoveryVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ServiceRegistryAndDiscoveryVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new PublisherVerticle());
    vertx.deployVerticle(new GreeterRestVerticle());
    vertx.deployVerticle(new ConsumerVerticle());
  }
}
..............................................................................................
				   
Assigment:

1.Create TODOProvider Rest api and TodoConsumer Rest api

User----/api/todos-------TodoProvider------WebClient-or EventBus---TodoConsumer
									|
									JDBC pool - 								 CREATE,UPDATE,DELETE

We have to use Discovery to publish webclient reference , and jdbcsource if possible.

Connection informations must be passed to verticle from configuration file.
....................................................................................
			  Reactive Microservices
....................................................................................

Vertx apps can be built using two styles

1.callback style 
2.reactive style

In Both style vertx apps are non blocking.

Reactive programming enables the program more declarative and expressive.

The origin of reactive programming started in Microsoft.

It is concerned with data streams and the propagation of change. 

In computer science, a stream is a sequence of data elements made available over time. 

A stream can be thought of as items on a conveyor belt being processed one at a time rather than in large batches.

In distributed computing(microservices), objects talk each other...

Objects talk each in order to exchange messages(data).

The object called caller(consumer) and other object called callee(publisher)

Caller and callee may communicate in sync style or async style......

Async way of communication is enabled via "Message Brokers" such as MOM middlewares,Event bus.


Reactive Programming is built on the top of 

1.Observable design pattern
2.Iterator design pattern
3.Using functional programming principles such pure functions,immutablity

Erik implemented reactive programming principles in .NetPlatform initally.

After this "Netflix" Insipired , Introduced in side java as  open source project called "RxJava" -  Reactive Extensions for java.

After this, the reactive programming became very popular, so that standards was needed.
https://reactivex.io/
https://www.reactivemanifesto.org/
https://www.reactive-streams.org/

...........................................................................................
				  Reactive Implementation
............................................................................................
Reactive programming is lanaguage independant, you can use in any langugage.

java implementation -libs
1.Rxjava  - netflix
2.project reactor - pivtol
3.mutiny - redhat

.....................................................................................			 Rxjava - Vertx with RxJava makes Vertx apps reactive
.....................................................................................

Core Concepts:

1.Publisher
2.Subscribers
3.Processing api-Operators


1.Publisher :
  It is object who emits event.
Types of event
1.data event
  when ever publisher push the data into stream, then this event is emitted 
2.error event
   when ever publisher push the error into stream, then this event is emitted 
3.complete
  when ever publisher finds, no more data /error to be pushed, then this event is called.

when ever error or complete event is called, the stream to be closed.

2.Subscriber
   It is object who listens for events - data,error,complete
 subscriber is based observer pattern, having methods called automatically for an event.

3.Operators
   methods which are based on functional programming priniciples
 -higher order function
 -Pure functions - which never mutates the same memory address

Pure function has two basic principle

1.function takes same parameter and returns the same .

   pure function
   public int update(int a) {
         return a;
   }

 impure function
public int update(int a) {
         return a++;
   }

2. function takes some parameter,we need to modify the parameter

  impure function
   public Collection update(List a){

        return a.add(something);
   }

if you want to modify the data, dont modify the original memory address, just clone it and return new object-immutablity

pure function
  public Collection update(List a){

        return a.clone().add(something);
   }
.............................................................................................

1.Producer/Publisher Objects

1.Observable
2.Subject
3.Single
4.Maybe
5.Completeable
6.Flowable

Subscriber Objects
1.Observer

1.Observer
2.Subscriber

Binding Object:

3.Subscription

Data Processing /Observation:
..............................

data processing done through apis - are called as operators.

Operators:
 Operators are methods in java /function which does some operation.

-Operators have been designed based on functional programming prinples
    -pure function,immutable,declarative,composable.

Operators:
are classified into various category
-create Stream
-tranformation
-filtering
-coimbing
-Error handling
-utility 
-conditional and boolean
-mathmetical and aggregate
-backpressue
-connectable
-converter

...........................................................................................
				    Coding : Rxjava 
............................................................................................

Project setup:

1. via maven
2. dependency 
    rxjava

package com.amex.reactive;

import io.reactivex.rxjava3.core.Observable;

import java.util.Date;

public class FirstStream {
    public static void main(String[] args) {
        Observable<String> observable = Observable.create(observer -> {
	    observer.onNext("hello");
            observer.onNext("hai");
            Thread.sleep(10000);
            observer.onNext("welcome");
            observer.onComplete();
        });
        //Listen for event
        observable.subscribe(data -> {
            System.out.println(data + new Date());
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Completed");
        });
    }
}

..............................................................................................
					Data Sources
..............................................................................................

Where data is stored? any datasource can be converted into stream.

DataSources:
1.primitives - int,float,double.
2.String
3.Objects
4.Array
5.Collection Types - List,Set
6.Future
7.Data Adapters -  Databases, devices....

Creational Operators:
.....................
create
defer
empty
error
from
generate
interval
just
never
range
timer
package com.amex.reactive;

import io.reactivex.rxjava3.core.Observable;

import java.util.Arrays;
import java.util.List;

public class CreationalOperator {
    public static void main(String[] args) {
//                Observable<Integer> intStream =Observable.create(observer->{
////            observer.onNext(1);
////            observer.onNext(2);
//              observer.onComplete()
////        });
        Observable<Integer> intStream = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        intStream.subscribe(System.out::println, System.out::println,
                () -> System.out.println("done"));

        Integer[] items = {1, 2, 3, 4, 5, 6};
        Observable<Integer> stream = Observable.fromArray(items);
        stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

        Integer[] itemsList = {1, 2, 3, 4, 5, 6};
        List<Integer> list = Arrays.asList(itemsList);
        Observable<Integer> listStream = Observable.fromIterable(list);
        listStream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

        Observable<Integer> rangeStream = Observable.range(1, 1000);
        rangeStream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

    }
}

Stream varients:
package com.amex.reactive;

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class StreamVarients {
    public static void main(String[] args) throws InterruptedException {
        //        I dont want to send data,or error,only complete signal
//        empty
        Observable stream = Observable.empty();
        stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));
        Observable<String> errorStream = Observable.error(new RuntimeException("Something went wrong"));
        errorStream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

        //infnite
        Observable<Long> clock = Observable.interval(1000, TimeUnit.MILLISECONDS);
        clock.subscribe(System.out::println, System.out::println,
                () -> System.out.println("done"));
        Thread.sleep(Long.MAX_VALUE);
    }
}
....................................................................................

package com.amex.reactive;

import io.reactivex.rxjava3.core.Observable;

public class StreamProcessing {
    public static void main(String[] args) {
        // transform();
        filter();
    }

    private static void filter() {
        Observable
                .range(1, 20)
                .filter(i -> {
                    System.out.println("Item got " + i);
                    return i >= 5;
                })
                .subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

    }

    public static void transform() {
        //Fluent pattern/builder pattern
        Observable.range(1, 20)
                .map(a -> {
                    System.out.println("item emitted 1 -> " + a);
                    return a * 10;
                }).map(b -> {
                    System.out.println("item emitted 2 -> ");
                    return b * 2;
                })
                .subscribe(System.out::println,
                        System.out::println,
                        () -> System.out.println("done"));

    }
}
Pipe Line:

Req:
 double the numbers, find even numbers, i need last 3 numbers

  -------a--,b--------------------------------------------> upstream
                map(doubleIt)
  -----------------------------------------------------> downstream --- upstream
                filter(isEven)
  ------------------------------------------------------> downstream --- upstream
                take(3)
 ------------------------------------------------------> downstream --- upstream

  subscribe
 ------------------------------------------------------>downstream


   private static void createPipeLine() {
        Observable
                .range(1, 20)
                .map(Operators::doubleIt)
                .filter(Operators::isEven)
                .take(3)
                .subscribe(System.out::println, System.out::println, () -> System.out.println("done"));
    }
.....................................................................................
............................................................................................
			         RxJava Streo Types
.............................................................................................
Streo types :
 Bean
   -Component,Service,Repository,Controller

Rx java Streo Types:
...................
Observable - o---n 
Single - only item
Maybe - single or empty
Completeable - only complete

Single:
......
RxJava (and its derivatives like RxGroovy & RxScala) has developed an Observable variant called “Single.”

A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.


Maybe:

Maybe is similar to Single . but special Singles

only item: Maybe.just
only completed single: Maybe.empty
only error : Maybe.error

Completeable: only complete signal
package com.amex.reactive;

import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;

public class StreoTypes {
    public static void main(String[] args) {
          // createSingle();
       // createMayBe();
        createCompleteable();
    }

    private static void createCompleteable() {
        Completable.complete().subscribe(() -> System.out.println("Completeable"));
    }
    private static void createMayBe() {
        //only item
        Maybe.just(1).subscribe(System.out::println);
        //only error
        Maybe.error(new RuntimeException("error")).subscribe(System.out::println, System.out::println);
        //only complete
        Maybe.empty().subscribe(System.out::println, System.out::println, () -> System.out.println("onComplete"));
    }

    private static void createSingle() {
        Single.create(emitter -> {
            emitter.onSuccess("Hello");
            emitter.onSuccess("Hi");
        }).subscribe(System.out::println);

        Single.create(emitter -> {
            emitter.onError(new RuntimeException("error"));
        }).subscribe(System.out::println, System.out::println);

        Single.just(1).subscribe(System.out::println);

//          Single.just(1,2,3).subscribe(System.out::println);

    }
}
..............................................................................................
				  Reactive Streams
.............................................................................................

What is reactive Stream?

It is standard for java echo systems to reactive libs/frameworks/apis
Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure.

Asynch Streaming + Back Pressure.

Back Pressure:

Upstream is faster enough to stream data to downstream , where downstream is unable to process data.
   -Back Pressure.

When back pressure happens , 
  -data loss
  -data inconsisistency

How to handle back pressure?

How to manage backpressure?

we have various patterns


Rxjava 1.x 
 -Through backpressure operators
Buffer
Sample
Debounce
Window
filter
.....

backpressure operators
 strategies for coping with Observables that produce items more rapidly than their observers consume them

1.Via Operators:

Most of the Flitering Operators are back pressure managed operators
 debounce,distinct,ElementAt,filter,first,ignoreElements,Last,sample,skip,skipLast,take,takeLast.

During backpressure, items may be droped
 drop operators: fliter
 collecting operators: window,buffer

2.Reactive Pull
..............
Above two strategies manage backpressure by dropping items, if your application need to process all the items emitted by source observable then you can’t use those strategies.

In this scenario, using reactive pull strategy is the right choice. In reactive pull, subscriber requests required number of items from observable by calling request().

PUSH + PULL = Reactive PULL

Down Stream can control up stream with help of mediator object that is called
"Subscription object"

DownStream --------Subscription ---------UpStream

DownStream --------Subscription ---------UpStream
                        |
                 request(no-elements)


Reactive Streams:
.................
   Reactive Stream is spec published to enable backpressure and create Back Pressure streams.-https://www.reactive-streams.org/

How provide backPressure handling feature at api level or Publisher level?

Soultion : Publisher level, in order to provide publisher , Many companies joined together

who published another spec "Reactive Stream"

Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.


The Team provided common spec:


The Team provided common spec:

1.Publisher
2.Subscriber
3.Subscription
4.Processor

After this spec published, Rxjava team relased new version - Rxjava 2 which implements reactive stream specification..

Rxjava 1 - has no implementation of "Reactive Stream Spec"

Rxjava 2 - Reactive Stream Spec implemented.

Rxjava 2 Provided one Simple Observable.


Flowable vs Observable

Flowable 
  emits 0...n items
  backpressure ready streams
  implements reactive stream spec

Observable
  emits 0..n items
  no backpressure
  no reactive stream stream spec.



map vs flatMap:

map is used to transform and return a data.

flatMap is used to transform and flatten inner observable.
package com.del.reactive.operators.transformation;

import io.reactivex.rxjava3.core.Observable;

public class FlatMapOperator {
    public static void main(String[] args) {
        Observable.just("A", "B", "C")
                .map(String::toLowerCase)
                .subscribe(
                        System.out::println, System.out::println, () -> {
                            System.out.println("done");
                        }
                );
        //flat map. i want to return [1,2,3] for each item
        Observable.just("A", "B", "C")
                .flatMap(i -> {
                    System.out.println("item " + i);
                    return Observable.just(1, 2, 3);
                })
                .subscribe(
                        System.out::println, System.out::println, () -> {
                            System.out.println("done");
                        }
                );
    }
}

....................................................................................
			Broad Casting
.....................................................................................

Producer(Stream)-----can be connected with ---one Subscriber : 
  one to one  This communication style is called "unicast".

Producer(Stream)----can be connected with ----->many subscribers : 
one to Many  This communication style is called "Multicast".

Based on Multicast communication style stream can be classified into two category.

1.Cold Observable(Cold Stream)
2.Hot Observable(Hot Stream)


1.Cold Observable

1.Observable that doesn’t emit items until a subscriber subscribes.

2.If we have more than one subscriber, then observable will emit sequence of items to all subscribers one by one. : cold

3.Each subscriber get fresh copy of the data from the begining.

4.Most of Observerables are Cold.

package com.mycom;

import io.reactivex.Observable;

import java.util.concurrent.TimeUnit;

public class ColdStream {
    public static void main(String[] args) throws InterruptedException {
        //
        Observable<Long> myObservable = Observable.interval(1, TimeUnit.SECONDS);

        myObservable.subscribe(item -> System.out.println("Observer 1: " + item));
        //after 3scs new subscriber joins
        Thread.sleep(3000);
        myObservable
                .doOnSubscribe((r) -> System.out.println("Observer 2 Joining"))
                .subscribe(item -> System.out.println("Observer 2: " + item));
        Thread.sleep(5000);

    }

}


Hot Observable:

1.Observables that don’t wait for any subscription. They start emitting items   when created.
2.They don’t emit the sequence of items again for a new subscriber.

3.When an item is emitted by hot observable, all the subscribers that are   subscribed will get the emitted item at once.


There are many ways to implement hot observables:

1.ConnectableObservable
2.Subjects


1.ConnectableObservable:
 Used to convert cold stream into hot stream

package com.mycom;

import io.reactivex.Observable;
import io.reactivex.observables.ConnectableObservable;

import java.util.concurrent.TimeUnit;

package com.mycom;

import io.reactivex.Observable;
import io.reactivex.disposables.Disposable;
import io.reactivex.observables.ConnectableObservable;

import java.util.concurrent.TimeUnit;

public class HotStream {
    public static void main(String[] args) throws InterruptedException {
        //cold observable
        Observable<Long> myObservable = Observable.interval(1, TimeUnit.SECONDS);
        //convert cold into hot
        ConnectableObservable<Long> connectableObservable = myObservable.publish();
        //try to connect all subscribers under one single unit.
        connectableObservable.connect();

      connectableObservable
                .doOnSubscribe((r) -> System.out.println("Observer 1 Joining"))
                .subscribe(item -> System.out.println("Observer 1: " + item));
        Thread.sleep(3000);
        Disposable subscriber2 =  connectableObservable
                .doOnSubscribe((r) -> System.out.println("Observer 2 Joining"))
                .doOnDispose(() -> System.out.println("Subscriber 2 left session"))
                .subscribe(item -> System.out.println("Observer 2: " + item));
        Thread.sleep(3500);
        subscriber2.dispose();
        connectableObservable
                .doOnSubscribe((r) -> System.out.println("Observer 3 Joining"))
                .subscribe(item -> System.out.println("Observer 3: " + item));
        Thread.sleep(8000);

    }
}

/////////////////////////////////////////////////////////////////////////////////////////////
				Subjects
.............................................................................................

 Subject a “hot” Observable variant of the original “cold” Observable

Varieties of Subject:

1.AsyncSubject 

It emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes.

(If the source Observable does not emit any values, the AsyncSubject also completes without emitting any values.)

package com.del.reactive.operators.multicast.subjects;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.subjects.AsyncSubject;

public class HotAsyncSubject {
    public static void main(String[] args) {

        Observable<Integer> sourceStream = Observable.create(subscriber -> {
            for (int i = 0; i <= 20; i++) {
                subscriber.onNext(i);
            }
           subscriber.onComplete();
        });
//        Observable<Integer> sourceStream = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        //Create Async Subject
        AsyncSubject<Integer> asyncSubject = AsyncSubject.create();
        //connect source stream with async subject
        sourceStream.subscribe(asyncSubject);

        asyncSubject.subscribe(data -> {
            System.out.println("Subu's AsyncSubject Subject :" + data);
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Done!");
        });
        asyncSubject.subscribe(data -> {
            System.out.println("Ram's AsyncSubject Subject :" + data);
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Done!");
        });
    }
}
.............................................................................................
BehaviorSubject:


-When an observer subscribes to a BehaviorSubject, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).

 BehaviourSubject emits the most recently item at the time of subscription or
 a default item if none has been emitted and then continues the sequence until complete.

package com.del.reactive.operators.multicast.subjects;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.subjects.BehaviorSubject;

import java.util.concurrent.TimeUnit;

public class HotBehvaiourSubject {
    public static void main(String[] args) throws InterruptedException {
        //soure stream
      //  Observable<Long> sourceStream = Observable.interval(1000, TimeUnit.MILLISECONDS);
        
        //This will emit default value
        Observable sourceStream = Observable.create(observer->{

        });
        //create Behaviour Subject
        BehaviorSubject<Long> behaviorSubject = BehaviorSubject.createDefault(0l);
        //connecting source stream with Behaviour
        sourceStream.subscribe(behaviorSubject);

        System.out.println("Wait for some seconds");
        Thread.sleep(10000);
        // BehaviourSubject emits the most recently item at the time of subscription
        behaviorSubject.subscribe(data -> {
            System.out.println("Subu's BehaviorSubject Subject :" + data);
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Done!");
        });

        behaviorSubject.subscribe(data -> {
            System.out.println("Ram's BehaviorSubject Subject :" + data);
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Done!");
        });
        System.out.println("Wait for some seconds");
        Thread.sleep(10000);
    }
}
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
			  Vertx with Reactive Extension
.....................................................................................

Vertx integrates reactive extension via rxjava 2 or 3 or mutiny.

Most of the Vertx apis including verticles enabled with reactive.

How to enable reactive vertx?

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-rx-java3</artifactId>
    </dependency>

Vertx original core API with helpers class that provides static methods for converting objects between vert.x core and Rxjava 2 api

RxHelper
ObservableHelper
FlowableHelper
SingleHelper
MaybeHelper
CompletableHelper

     via the "Rxified Vertx api enchancing the Vertx Core api"


package com.amex.reactive;

import io.reactivex.rxjava3.core.Single;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.rxjava3.core.AbstractVerticle;
import io.vertx.rxjava3.core.eventbus.EventBus;
import io.vertx.rxjava3.core.http.HttpServer;
import io.vertx.rxjava3.ext.web.client.HttpResponse;
import io.vertx.rxjava3.ext.web.client.WebClient;
import io.vertx.rxjava3.ext.web.codec.BodyCodec;

class ReactiveWebClient extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    vertx.createHttpServer().requestHandler(req -> {
      WebClient webClient = WebClient.create(vertx);
      Single<HttpResponse<String>> request = webClient
        .get(3000, "localhost", "/")
        .as(BodyCodec.string()).rxSend();
      //fire the http call
      request.subscribe(result -> {
        req.response().end(result.body());
      });
    }).rxListen(3001).subscribe();
  }
}

class EventBusReactive extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    EventBus eventBus = vertx.eventBus();

    eventBus.consumer("com.amex.addr").toFlowable().subscribe(message -> {
      System.out.println(message.body().toString());
      message.reply("PONG");
    });
    vertx.setPeriodic(1000, v -> {
      eventBus.rxRequest("com.amex.addr", "PING").subscribe(reply -> {
        System.out.println("Received Reply " + reply.body());
      });
    });
  }
}


class WebServerVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);

    HttpServer httpServer = vertx.createHttpServer();
    httpServer.requestStream().toFlowable().subscribe(req -> {
      req.response().end("Stream data over http using web client");
    });
    httpServer.rxListen(3000).subscribe(server -> {
      System.out.println("Server is running");
    });
  }
}

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);

  }
}

public class ReactiveMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ReactiveMainVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    vertx.deployVerticle(new GreeterVerticle()).subscribe(res -> {
      System.out.println(res);
    }, err -> {
      System.out.println(err);
    });
    vertx.deployVerticle(new WebServerVerticle()).subscribe(res -> {
      System.out.println(res);
    }, err -> {
      System.out.println(err);
    });
    vertx.deployVerticle(new EventBusReactive()).subscribe(res -> {
      System.out.println(res);
    }, err -> {
      System.out.println(err);
    });
    vertx.deployVerticle(new ReactiveWebClient()).subscribe(res -> {
      System.out.println(res);
    }, err -> {
      System.out.println(err);
    });
  }
}
.....................................................................................
			Scallablity and High Availablity
.....................................................................................
Vertx Types:
...........

1.Standard Vertx  - Single vertx engine
2.Clustered Vertx - Mutliple vertx engine

Lets assume i have one verticle which hosts single web server, what if that webserver is down, then client cant talk.

Can we scale the Verticles - Having multiple instances of Single server - clone of verticles.

Running the verticle more no of times.

DeploymentOptions options = new DeploymentOptions().setInstances(5);

vertx.rxDeployVerticle(GreeterService.class.getName(), options).subscribe(res -> {
      System.out.println(GreeterService.class.getName() + " " + res);
    }, err -> {
      System.out.println(err);
});

Rules when we deploy verticles in scalling:

1.class must be public.
2.deployVericle method must take fully qualified class name ("com.amex.MyClass")
  you should not use new Keyword

eg:
package com.amex.distributed.scalling;

import io.vertx.rxjava3.core.AbstractVerticle;
import io.vertx.rxjava3.core.http.HttpServer;

public class GreeterService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    HttpServer httpServer = vertx.createHttpServer();
    httpServer.requestStream().toFlowable().subscribe(req -> {
      req.response().end("Hello!How are you : " + Thread.currentThread().getName() + " =>" + hashCode());
    });
    httpServer.rxListen(3000).subscribe(onSuccess -> {
      System.out.println("Server is Running on " + onSuccess.actualPort());
    });
  }
}

package com.amex.distributed.scalling;

import io.vertx.core.DeploymentOptions;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.rxjava3.core.AbstractVerticle;

public class ScallerDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ScallerDeployer.class.getName());
  }

  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    DeploymentOptions options = new DeploymentOptions().setInstances(5);
    vertx.rxDeployVerticle(GreeterService.class.getName(), options).subscribe(res -> {
      System.out.println(GreeterService.class.getName() + " " + res);
    }, err -> {
      System.out.println(err);
    });
  }
}
....................................................................................
			  Clustered Vertx
....................................................................................

Vertx is distributed system.
We can deploy verticles across multiple vertx engines which may be across machines in the network.
Vertx engines form group called "Cluster".
Cluster is group of machines.
Cluster informations are managed by Cluster Manager.

Vertx communicates via network using cluster managers

Vertx supports cluster manager software

1.Hazelcast - it is default cluster manager which distribued with vertx..
2.Kubernets as Cluster Manager
3.ZooKeeper as cluster Manager

<dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-hazelcast</artifactId>
</dependency>

Vertx Engine Configuration:
...........................

ClusterManager mgr= new HazlelCastClusterManager();
VertxOptions options=new VertxOptions().setClusterManager(mgr);
Vertx.clustered(options).onComplete(res->{
  Vertx vertx =res.result(); 
  vertx.deployVerticle()
})

Publisher Code:
...............
package com.amex.distributed.scalling.clustering;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class PublisherVerticle extends AbstractVerticle {

  public static void main(String[] args) {

    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions()
      .setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {
        //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions()
          .setInstances(2).setHa(true);
        vertxAsyncResult.result().deployVerticle("com.amex.distributed.scalling.clustering.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!" + res.cause());
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
    String jvmName = runtimeBean.getName();
    //processid
    long pid = Long.valueOf(jvmName.split("@")[0]);
    vertx.setPeriodic(5000, ar -> {
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India" + " From  " + jvmName;
      vertx.eventBus().publish("news.in.covid", news);
    });

  }
}
...
Consumer Code:
package com.amex.distributed.scalling.clustering;


import io.vertx.core.*;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class ConsumerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");
    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        //Get the reference of Cluster Powered Vertx Engine
        Vertx vertx = cluster.result();
        //deploy the verticle in cluster.
        DeploymentOptions deploymentOptions = new DeploymentOptions().setInstances(3);
        cluster.result().deployVerticle("com.amex.distributed.scalling.clustering.ConsumerVerticle", deploymentOptions).onSuccess(res -> {
          System.out.println("Deployment Id => " + res);
        }).onFailure(err -> {
          System.out.println(err);
        });
      } else {
        // failed!
        System.out.println("Cluster is failed" + cluster.cause());
      }
    });


  }


  @Override
  public void start(Promise<Void> startFuture) throws Exception {
    super.start(startFuture);
    System.out.println("started");
    EventBus eventBus = (EventBus) vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("Node  Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });
  }
}
.....................................................................................

References:
...........
https://github.com/cescoffier/vertx-microservices-workshop
Vertx In Action 




