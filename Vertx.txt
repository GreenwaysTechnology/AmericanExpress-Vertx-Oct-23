					Vert.x:

What is Eclipse Vert.x ?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

toolkit is nothing but you can embed into any exiting applications written by using language or framework or lib.

Framework is infrastructure for building application end to end , in order to apps written in frameworks , we need framework runtimes such as spring.

 Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.

Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Now a days, Vertx has been standardized only three languages - java,kotlin,groovy.

Vert.x doesn't preach about what language is best — you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.

How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                    compilers
                        |
                      .class
                        |
                       jvm
.....................................................................................
 		Building block of Vertx-Vertx Architecture
.....................................................................................

NonBlocking io:
...............


IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.

The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.

File Descriptor:
..................

File descriptor or file descriptor table is nothing but , it is "c" program which has all information about  io opertaions.

Fd is bridge between application runtime/process and io devices.


Blocking io code in java:
........................

blocking network socket app.


import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class BlockingEco {
    public static void main(String[] args) throws Throwable {
        //this api interally communicates network interface card
        ServerSocket server = new ServerSocket();
        server.bind(new InetSocketAddress(3000));
        System.out.println("Blocking Socket : listening for new Request");
        while (true) {   // <1>
            Socket socket = server.accept();
            //each incomming request(socket request) allocate in a separate thread
            new Thread(clientHandler(socket)).start();
        }
    }

    private static Runnable clientHandler(Socket socket) {
        return () -> {

            try (
                    BufferedReader reader = new BufferedReader(
                            new InputStreamReader(socket.getInputStream()));
                    PrintWriter writer = new PrintWriter(
                            new OutputStreamWriter(socket.getOutputStream()))) {
                String line = "";
                while (!"/quit".equals(line)) {
                    line = reader.readLine();      // <2>
                    System.out.println("~ " + line);
                    writer.write(line + "\n");  // <3>
                    writer.flush();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
    }

}

Why not blocking?

Blocking APIs waste resources, increase costs


The main problem with the code above ,is that it allocates a new thread for each incoming connection(request) and threads are anything but cheap resources. 

A thread needs memory, and the more threads you have, the more you put pressure on the operating system kernel scheduler, as it needs to give CPU time to the thread

 Input/output operations such as readLine and write may block the thread, meaning that it is being parked by the operating system. This happens for two reasons:

A read operation may be waiting for data to arrive from the network.
A write operation may have to wait for buffers to be drained if they are full from a previous write operation

NonBlocking io  = IO Multiplxing (Nonblocking io,SIGIO,POSX_IO FUNCTIONS)

Today there are two io programming models = blocking and io multiplexing(Non,async)

Generally all webservers work based on "Request per thread Model".

2000,C10K - concurrently handling ten thousand connections.

2000, Linux operating system introduced a new api for io operations which does not block thread - "select"	

non blocking io operation: 

1.select + read - first non blocking io operation introduced in linux operating system.

2.poll - second non blocking io operation api introduced in linux. the difference is 
         poll pushing data from kernal to application process rather pulling data          from  kernal table.

3.Epoll -  this modern non blocking io api introduced in linux....

Other Operating system non blocking abstractions:

EPoll -Linux
IOCP - Windows
kqueue -mac and other open bsd versions.
.....................................................................................
java and non blocking:
......................

Does java support non blocking apis?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"-NONBlocking IO.

NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}
Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 
->It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
->Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

->This is why, in practice, developers rarely deal with Java NIO. 
.......................................................................................................

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        	     Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Objective of VertX:
   
    100% non blocking applications on jvm.


NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


/////////////////////////////////////////////////////////////////////////////////////

Vertx Runtime:

Vertx run time is powered by non blocking io arch

Vertx uses event loops
 -event loops are used to process events which are dispatched by kernal.
 -Event loops are just threads to process incoming events from kernal

Event :

  collection of event and data
  How to read data?
    you need handler- callback functions


Vertx uses multi core event loop threads where as node js has only one event loop thread.

Vertx uses per cpu core - 2 event loop, lets say i have 12 cores - 12 *2 =24 event loops.
....................................................................................

Lets enter into vertx app; how to build non blocking and async apps:
....................................................................

Lets code:

-Vertx Project setup
   -Maven Project
   -Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project
.................................................................................
			 How to create vertx cli project..

https://start.vertx.io/

Vertx application can be small to big enterprise microservice application.

Like spring , starts with spring-core , after that ,spring-mvc,spring-data....(modules)

Vertx also begins modules

vertx-core ,vertx-web,vertx-data..............etc...

vertx-core:

How to run vertx app?

Every Vertx apps will have entry point, configured in pom.xml

 <main.verticle>com.amex.MainVerticle</main.verticle>
 <launcher.class>io.vertx.core.Launcher</launcher.class>

How to run vertx apps?

1.compile the code and execute - dev mode.

mvnw clean compile exec:java

[INFO] Scanning for projects...
[INFO] 
[INFO] -----------------------< com.amex:vertxcoreapp >------------------------
[INFO] Building vertxcoreapp 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ vertxcoreapp ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ vertxcoreapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory E:\session\AMex\2023\vertxcoreapp\src\main\resources
[INFO]                                                                                         
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ vertxcoreapp ---            
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to E:\session\AMex\2023\vertxcoreapp\target\classes
[INFO] 
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ vertxcoreapp ---
HTTP server started on port 8888
Oct 16, 2023 2:22:56 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle

By default vertx offers some Webservice which is running in port 8888

http://localhost:8888/

2.Creating production apps -deployment 

mvnw clean package 

 This command gives two jars.
  
 Regular jar  
 fat jar

How to run ?

java -jar target/vertxcoreapp-1.0.0-SNAPSHOT-fat.jar
.....................................................................................
			   vertx Core concepts
.....................................................................................

Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.

Vertx Engine is a java class, represented as interface in the io.vertx.core package

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler)

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles

package com.amex;

import io.vertx.core.Vertx;

public class HelloVertx {
  public static void main(String[] args) {
    System.out.println("Creating vertx app");
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.getClass());

    System.out.println("Main thread" + Thread.currentThread().getName());
    //create simple web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println("Server");
      System.out.println("Vertx thread : " + Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}
.....................................................................................
Vertx modules:
...............
vertx-core
vertx-web
vertx-data
vertx-microservices
etc...


Verticles
Threading modles
callbacks
Promises
Futures


Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.

What is deployment?

The action of bringing "resources" into effective action

In vertx, Brining Resources ready  for computation.

Resources:
 -Thread creation /allocation
 -binding an object with that thread
 -Register all event handlers in case of event driven programming
 -Allocate memory if required for data/other 
 -Ensures that other depenendant resources or ready.

-It is based on design pattern called "Actor-like Model"
-Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init   - called when verticle being initalized
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment


if you are writing any verticle class, you cant use "Verticle" Interface directly.

Vertx provides an implementation abstract class called "AbstractVerticle" class.

io.vertx.core.AbstractVerticle
io.vertx.rxjava3.core.AbstractVerticle
io.vertx.rxjava.core.AbstractVerticle

How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}
package com.amex;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class MainVerticle extends AbstractVerticle {
  //override verticle life cycle methods

  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start method is called");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop method is called");
  }
}
.....................................................................................
	          How to create multiple verticles and deploy them
....................................................................................

There are many ways
1.within main verticle and deploy other verticles
2.write simple java class and through which you can deployment
3.Vertx provides a runner class through which also you can deploymnet

1.within main verticle and deploy other verticles


package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class MainVerticle extends AbstractVerticle {
  //override verticle life cycle methods
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start method is called");
    //deploy Greeter Verticle
    //vertx variable is already available within every verticle we create.
    // vertx.deployVerticle(new GreeterVerticle());
    //vertx.deployVerticle(GreeterVerticle.class.getName());
    vertx.deployVerticle("com.amex.verticles.GreeterVerticle");

  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop method is called");
    vertx.undeploy("com.amex.verticles.GreeterVerticle");
  }
}
....................................................................................

From plain java code how to deploy verticles?
.............................................

package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.Vertx;

public class VertlcleDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new GreeterVerticle());
  }
}

This code will not call life cycle method like stop.
This is not recommended way of deploying verticles.

Runner/Lanucher class
.......................
Lanuching vertx applications using main method without using "maven/gradle" configuration.
package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;

public class LanucherDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", LanucherDeployer.class.getName());
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Deployer starting");
    vertx.deployVerticle(new GreeterVerticle());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Deployer ending");
  }
}

Output:
Deployer starting
GreeterVerticle
Oct 16, 2023 4:37:14 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
GreeterVerticle has been stopped
Deployer ending
.....................................................................................
			  Vertx Coding Style
...................................................................................

Patterns to write non blocking apps:

1.callback style -traditionals way.
2.Reactive style -Streaming pattern

Non blocking apis
1.timer
2.http
3.fs
4.socket
5.database
etc.......

Callback/Listener Style:
1.Future
2.Promises

if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".


Handler Function /Callback function/Listener function:
.......................................................
1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop thread starts processing event by assinging a handler function.

What is handler function/callback function/listener function for?

 "To handle async success /failure result"
     "The result of async opertion could be either success or failure".

io.vertx.Future:

-it is interface used to handle async success/failure results.
-vertx uses Future(Object) to represent "Asynchronous" Results
-Future is like transport object to transport data between caller and callee in async  manner

Caller -------Future-----Callee


What type of data Future can carry?

-Success--------|
                  ---->Future
-Failure--------|


AsynResult<T>:

Encapsulates the result of an asynchronous operation.

Object which has either success data or failure data.

If it failed then the cause of the failure is available with cause().

If it succeeded then the actual result is available with result()


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation

 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.

Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure



AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success
....................................................................................

Use case: Get Empty Future

package com.amex.futures;

import io.vertx.core.*;

public class FutureDemoVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureDemoVerticle.class.getName());
  }

  //Callee
  //create simple future and return no Result.
  public Future<Void> getEmptyFuture() {
    //create Future Object : Anonymous pattern using java inner class
//    Future<Void> future = Future.future(new Handler<Promise<Void>>() {
//      @Override
//      public void handle(Promise<Void> event) {
//        event.complete();
//      }
//    });
    // create Future Object : using lambda pattern:It is recommended
    Future<Void> future = Future.future(event -> {
      event.complete();
    });
    return future;
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Future Verticle");
    //caller
//    getEmptyFuture().onComplete(new Handler<AsyncResult<Void>>() {
//      @Override
//      public void handle(AsyncResult<Void> event) {
//        //here only we grab result
//        if (event.succeeded()) {
//          System.out.println("Success");
//          event.result();
//        } else {
//          System.out.println("Failed");
//          System.out.println(event.cause().getMessage());
//        }
//      }
//    });
    getEmptyFuture().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("Success");
        event.result();
      } else {
        System.out.println("Failed");
        System.out.println(event.cause().getMessage());
      }
    });
  }
}
....................................................................................

Future with data,error, data and error:
......................................
package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureWithData extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithData.class.getName());
  }

  //Return data with Future.
  public Future<String> sayHello() {
    return Future.future(future -> future.complete("Hello"));
  }

  //return error data with Future
  public Future<String> getError() {
    return Future.future(future -> future.fail("Something went wrong!"));
  }

  //future with biz logic
  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }


  @Override
  public void start() throws Exception {
    super.start();
    //subscribe future .
    sayHello().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    //grab error Message
    getError().onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      }
    });
    //login with success and error
    login("admin", "admin").onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      } else {
        System.out.println(event.result());
      }
    });
    //login with failure data
    login("foo", "bar").onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      } else {
        System.out.println(event.result());
      }
    });
  }
}
.....................................................................................
Shortcuts for Listener Code;
.............................

Listener api Which returns Future.

Syntax:
someApi().onComplete(Handler<AsynResult>)
someApi().onSuccess(res->{});
someApi().onError(err->{});
someApi().onSuccess(res->{}).onError(err->{});
someApi().onSuccess(System.out::println).onError(System.out::println);

package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureWithData extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithData.class.getName());
  }

  //Return data with Future.
  public Future<String> sayHello() {
    return Future.future(future -> future.complete("Hello"));
  }

  //return error data with Future
  public Future<String> getError() {
    return Future.future(future -> future.fail("Something went wrong!"));
  }

  //future with biz logic
  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    //short cut apis
    //sayHello().onSuccess(res -> System.out.println(res));
    sayHello().onSuccess(System.out::println);
    getError().onFailure(System.out::println);
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}
.....................................................................................
			 Future Object Creation Patterns
....................................................................................

Pattern 1: Factory Method pattern

Future.future()

  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }

Pattern 2:

Future.succeedFuture() - Returns success Result
Future.failedFuture() -> Returns failure Result.

 public Future<String> auth(String userName, String password) {
    if (userName.equals("admin")) {
      return Future.succeededFuture("Login Success");
    }
    return Future.failedFuture("Login Failed");
  }

Pattern 3 :
 Instead of Returning Future, We can pass function as Parameter(Higher Order Function)

    authenticat("admin", "admin", handler -> {
      if (handler.failed()) {
        System.out.println(handler.cause().getMessage());
      } else {
        System.out.println(handler.result());
      }
    });

Full code:
package com.amex.futures;

import io.vertx.core.*;

public class FutureObjectCreationPatterns extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureObjectCreationPatterns.class.getName());
  }

  //Pattern 1:
  public Future<String> login(String userName, String password) {
    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });
  }

  //Pattern 2:
  public Future<String> auth(String userName, String password) {
    if (userName.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login Success");
    }
    return Future.failedFuture("Login Failed");
  }

  //Pattern 3: Function as parameter : Higher order function
  public void authenticat(String userName, String password, Handler<AsyncResult<String>> asyncHandler) {
    if (userName.equals("admin") && password.equals("admin")) {
      asyncHandler.handle(Future.succeededFuture("Login success"));
    } else {
      asyncHandler.handle(Future.failedFuture("Login Failed"));
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //pattern 1:
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    // pattern 2:
    auth("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

    //Pattern 3:
    authenticat("admin", "admin", handler -> {
      if (handler.failed()) {
        System.out.println(handler.cause().getMessage());
      } else {
        System.out.println(handler.result());
      }
    });
  }
}
.....................................................................................
		     Callback Chaining - Nested Callbacks
.....................................................................................

In Sync application, the flow will go step by step

Connection conn = DriverManager.getConnection();
Statement st = conn.createStatement();
ResultSet rows = st.executeQuery();

Here flow will go based on previous statement , one after another another.


Connection conn = DriverManager.getConnection();
Statement st = conn.createStatement();
ResultSet rows = st.executeQuery();
FormateResult()
AddResponse into http Stream
send Response to the client
....................................................................................

What if the same task can be done in functional programming or async way; Vertx

Functional sequential work flow
  Nested callbacks , callback chaining, functional style.
 
Handler function is called as callback function.

"The output of one callback is input to the another callback: nested callbacks".

 cb1
   --cb2
       --cb3
            --cbN
                  --process the result


Use Case:
   getUser() -----if user is available(success)
			|
			 -----call login method with output of getUser
			|
		 if failed
		     |
		     You throw error

Note: The output of one callback will be input to another function.
............

Code:
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

//Model class
class User {
  private String userName;
  private String password;

  public User() {
  }

  public User(String userName, String password) {
    this.userName = userName;
    this.password = password;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @Override
  public String toString() {
    return "User{" +
      "userName='" + userName + '\'' +
      ", password='" + password + '\'' +
      '}';
  }
}

public class CallbackVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackVerticle.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(userHandler -> {
      if (userHandler.succeeded()) {
        // System.out.println(userHandler.result());
        //call login method
        login(userHandler.result()).onComplete(loginHandler -> {
          if (loginHandler.succeeded()) {
            //call show dashboard
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.succeeded()) {
                System.out.println(dashboardHandler.result());
              } else {
                System.out.println(dashboardHandler.cause().getMessage());
              }
            });
          } else {
            System.out.println(loginHandler.cause().getMessage());
          }
        });
      } else {
        System.out.println(userHandler.cause().getMessage());
      }
    });
  }
}
.....................................................................................
			  Callback Hell
.....................................................................................
getUser().onComplete(userHandler -> {
      if (userHandler.succeeded()) {
        // System.out.println(userHandler.result());
        //call login method
        login(userHandler.result()).onComplete(loginHandler -> {
          if (loginHandler.succeeded()) {
            //call show dashboard
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.succeeded()) {
                System.out.println(dashboardHandler.result());
              } else {
                System.out.println(dashboardHandler.cause().getMessage());
              }
            });
          } else {
            System.out.println(loginHandler.cause().getMessage());
          }
        });
      } else {
        System.out.println(userHandler.cause().getMessage());
      }
    });

Look at the above code, ask your self.

1.IS it easy to understand
2.is it easy to scale
3.Is it easy to maintain

No!

 This is called  callback hell; The callback hell is way of writing complex callback based program.

Can we escape from the callback hell problem, or how to write better callback based programming.

Yes!.

Soultion 1:
............
Using onSuccess and onFailure.
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackVerticle.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
    getUser().onSuccess(user -> {
      login(user).onSuccess(status -> {
        showDashboard(status).onSuccess(page -> {
          System.out.println(page);
        }).onFailure(err -> System.out.println(err));
      }).onFailure(loginErr -> {
        System.out.println(loginErr.getMessage());
      });
    }).onFailure(userErr -> {
      System.out.println(userErr.getMessage());
    });
  }
}
........................

Solution 2: Using Future.compose method

Used to chain multiple callbacks in more readable way.
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackHellSoultion.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
//    getUser().onSuccess(user -> {
//      login(user).onSuccess(status -> {
//        showDashboard(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> System.out.println(err));
//      }).onFailure(loginErr -> {
//        System.out.println(loginErr.getMessage());
//      });
//    }).onFailure(userErr -> {
//      System.out.println(userErr.getMessage());
//    });

//    //solution 2: Using Future.compose method
    getUser().compose(user -> {
      return login(user);
    }).compose(status -> {
      return showDashboard(status);
    }).onSuccess(res -> {
      System.out.println(res);
    }).onFailure(err -> {
      System.out.println(err.getMessage());
    });

  }
}

Compose Refactoring: Using Lambdas

//Solution 2.1: Using Future.compose method lambda refactoring.

    getUser()
      .compose(user -> login(user))
      .compose(status -> showDashboard(status))
      .onSuccess(res -> {
        System.out.println(res);
      }).onFailure(err -> {
        System.out.println(err.getMessage());
      });

    //Soution 2.2 : Using Future.compose using Method reference
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
..........................
Callback Hell Solution code:
package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Future;

public class CallbackHellSoultion extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackHellSoultion.class.getName());
  }

  //getUser api
  private Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
//    user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User Not Found");
    }
  }

  //login api
  private Future<String> login(User user) {
    System.out.println("Login  is called");
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("login success");
    } else {
      return Future.failedFuture("Login failed ");
    }
  }

  //show dashboard
  private Future<String> showDashboard(String status) {
    System.out.println("showDashboard  is called");
    if (status.equals("login success")) {
      return Future.succeededFuture("You are admin");
    } else {
      return Future.failedFuture("You are not admin");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //solution 1:
//    getUser().onSuccess(user -> {
//      login(user).onSuccess(status -> {
//        showDashboard(status).onSuccess(page -> {
//          System.out.println(page);
//        }).onFailure(err -> System.out.println(err));
//      }).onFailure(loginErr -> {
//        System.out.println(loginErr.getMessage());
//      });
//    }).onFailure(userErr -> {
//      System.out.println(userErr.getMessage());
//    });

//    //solution 2: Using Future.compose method
//    getUser().compose(user -> {
//      return login(user);
//    }).compose(status -> {
//      return showDashboard(status);
//    }).onSuccess(res -> {
//      System.out.println(res);
//    }).onFailure(err -> {
//      System.out.println(err.getMessage());
//    });
    //Solution 2.1: Using Future.compose method lambda refactoring.

//    getUser()
//      .compose(user -> login(user))
//      .compose(status -> showDashboard(status))
//      .onSuccess(res -> {
//        System.out.println(res);
//      }).onFailure(err -> {
//        System.out.println(err.getMessage());
//      });
    //Soution 2.2 : Using Future.compose using Method reference
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}
.....................................................................................
			  Advanced Composition: CompositeFuture
....................................................................................

Lets say i have three methods

-startDbServer
-startHttpServer
-startConfigServer

 I need to ensure that my app must be initalized only , all servers are up, if any one server is failed, stop all servers/ dont initialize my app.

Future Coordination:
  Coordination of multiple futures can be achived with Vertx Futures.

Vertx supports concurrent composition(running serveral async operations in parall) and code looks like sequential - chaining async operations...

Syntax:
 CompositeFuture.all(f1,f2,f3,f4,f5,f6)

  -All composition waits until all futures are successfull or any one failed.


 CompositeFuture.any(f1,f2,f3,f4,f5,f6)
    Any one Compostion waits for any one succeedFuture.
   

package com.amex.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CompositFutureVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", CompositFutureVerticle.class.getName());
  }

  //start Db server
  public Future<String> startDbServer() {
    System.out.println("Db Server started");
    return Future.succeededFuture("Db Server is Up");
  }

  //start web server
  public Future<String> startWebServer() {
    System.out.println("Web Server is started");
   // return Future.succeededFuture("WebServer is Up");
    return Future.failedFuture("Failed WebServer startup");
  }

  //config Server
  public Future<String> startConfigServer() {
    System.out.println("Config Server is started");
    return Future.succeededFuture("ConfigServer is Up");
  }

  @Override
  public void start() throws Exception {
    super.start();
    Future<String> dbServer = startDbServer();
    Future<String> webServer = startWebServer();
    Future<String> configServer = startConfigServer();

    CompositeFuture.all(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
        //do something....
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

    System.out.println("...Any...");
    CompositeFuture.any(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All Server is Up");
        //do something....
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
  }
}
.....................................................................................
				Promises
....................................................................................

Dont confuse futures with promises

if futures are represent the "read side" of an asynchronous result, promises are the "write side".

Promises are inspired from java script largly.

Promises are semantically meaningfull abstraction for handling async result.

Most of the developers confuse with java Futures and Vertx Futures, in order to avoid confusion, promises were introduced.

Promises cant't be processed directly with "OnComplete/OnSuccess" apis

Promises must be converted into Future before processing.

package com.amex.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PromisesVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PromisesVerticle.class.getName());
  }

  //create Promise and encapulte the data and return.
  public Promise<String> getHelloPromise() {
    Promise promise = Promise.promise();
    promise.complete("Hello");
    return promise;

  }

  public Future<String> getHaiPromise() {
    Promise promise = Promise.promise();
    promise.complete("Hai");
    return promise.future();

  }

  @Override
  public void start() throws Exception {
    super.start();
    getHelloPromise().future().onSuccess(System.out::println);
    getHaiPromise().onSuccess(System.out::println);
  }
}
.....................................................................................
			  verticle start and stop method with promises
.....................................................................................

Async Verticle start and stop methods:

sometimes you want to do something in your verticle startup which takes some time and you dont want the verticle to be considered deployed until that happens.
For Eg you might want to start an http server start method and propagate the asyn result of server listen method.

The way to do it is to implement the asynchronous start method (Start with method with Promise Arg)
 This version of the method takes Promise as a parameter. when the method returns verticle will be not considered deployed.

Every verticle will have unique deploymentId, which can be used to undeploy the verticles

package com.amex.promises;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PromiseStartVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PromiseStartVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new GreeterVerticle(), ar -> {
      if (ar.succeeded()) {
        System.out.println(GreeterVerticle.class.getName() + " Deployement Id  " + ar.result());
        startPromise.future().onSuccess(System.out::println); //ensure that this verticle has been successfull
      } else {
        //startPromise.fail("Something went wrong");
      }
    });
  }

  @Override
  public void stop(Promise<Void> stopPromise) throws Exception {
    super.stop(stopPromise);
  }
}
.....................................................................................	
			 Building Non blocking or Async apps
.....................................................................................

in order to build non blocking io apps (network,filesystem) and timers, language or framework/lib/toolkit has to provide basic requirment.

1.Runtime should have faciltity to talk to low level operating system non blocking apis such as "select/poll/epoll-linux, iocp-windows,kqueue-mac,unix".

2.For Application developers , the language or framework/lib/toolkit must provide high level apis in order to communicate low level system calls api - vertx provides high level apis.

3.At runtime level, Runtime must provide threading features to listen for os kernal events. Event loop threads.

4.Program level, we must bind function to handle such events(callbacks)

Vertx non blocking apis:
.......................

1.Timer 
2.File System
3.Http Api
4.Socket api
5.Udp and DataGram 
etc....

Timer:
......

It is common in vertx to want to perform some action after a certain delay or perdically.

Timer is special non blocking api which schdules any task in delayed manner which does not block the current thread.

Task is executed by "CPU" level.

Timer is not part of FileDecriptor table because it is not an IO operation.

Types of timers:
1.one-shot timers
2.Periodic timers.

one-shot Timers:

1.Basic Timer:
package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class OneShotTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", OneShotTimerVerticle.class.getName());
  }

  //simple delay
  public void delay() {
    vertx.setTimer(1000, handler -> {
      System.out.println("I am delayed task");
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("start");
    delay();
    System.out.println("end");
  }
}
....................................................................................

What if i want to return certain result after time out?

package com.amex.async.timers;

import io.vertx.core.*;

public class TimerWithDataVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", TimerWithDataVerticle.class.getName());
  }

  //Data Transfer with Future with delay
  public Future<String> getMessage() {
    return Future.future(ar -> {
      vertx.setTimer(1000, handler -> {
        String response = "Hello!!!";
        ar.complete(response);
      });
    });
  }

  //Data transfer using callbacks pattern
  public void transfer(Handler<AsyncResult<String>> aHandler) {
    vertx.setTimer(2000, timerHandler -> {
      String response = "Hello,How are you!";
      aHandler.handle(Future.succeededFuture(response));
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("start");
    getMessage().onSuccess(System.out::println);
    transfer(aResult -> {
      if (aResult.succeeded()) {
        System.out.println(aResult.result());
      }
    });
    System.out.println("end");
  }
}

Periodic timers:
 Timers keeps which are keep on running...

vertx.setPeriodic(timer,callback)

package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }

  public void tick() {
    vertx.setPeriodic(1000, handler -> {
      System.out.println(Math.random());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    tick();
  }
}

What if i want to stop timers after some time?
setPeriodic() , which returns timerId, which can be used to cancel the timer...
package com.amex.async.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }

  public void tick() {
    long timerId = vertx.setPeriodic(1000, handler -> {
      System.out.println(Math.random());
    });
    //cancel the timer after certain time or certain condition
    vertx.setTimer(10000, handler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    tick();
  }
}
........
How to return data from the Periodic timer?

We cant return Future which encapuslate Periodic timer, because once if return future that cant hold next tick...

We have to use always callback pattern.
package com.amex.async.timers;

import io.vertx.core.*;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }


  public void tick() {
    long timerId = vertx.setPeriodic(1000, handler -> {
      System.out.println(Math.random());
    });
    //cancel the timer after certain time or certain condition
    vertx.setTimer(10000, handler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }

  //send data to the caller
  public void poll(Handler<AsyncResult<Double>> aHandler) {
    long timerId = vertx.setPeriodic(1000, handler -> {
      aHandler.handle(Future.succeededFuture(Math.random()));
    });
    //cancel the timer after certain time or certain condition
    vertx.setTimer(10000, handler -> {
      System.out.println("Stop Polling");
      vertx.cancelTimer(timerId);
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //tick();
    poll(ar -> {
      if (ar.succeeded()) {
        System.out.println(ar.result());
      }
    });
  }
}
.....................................................................................
			   Data Interchange Format - JSON
.....................................................................................
Json is one of the Most popular data interchange format in distributed application.

In order create Json, vertx provides JsonObject,JsonArray
package com.amex.json;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JsonVerticle.class.getName());
  }

  public Future<JsonObject> getUser() {
    Promise promise = Promise.promise();
    JsonObject user = new JsonObject();
    user.put("id", 1);
    user.put("name", "Subramanian");
    user.put("city", "Coimbatore");
    promise.complete(user);
    return promise.future();
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println("Id " + user.getInteger("id"));
      System.out.println("Name " + user.getString("name"));
      System.out.println("City " + user.getString("city"));
      System.out.println(user.encodePrettily());

    });
  }
}
...................................................................................
		 Fulent API/Fluent Patterns
..................................................................................

Insteam of writing multiple lines of code and storing them into multiple variables, we can chain apis, finally we can get output, This is sometimes called as builder pattern, in vertx we call them as fluent pattern.

Normal 
JsonObject user = new JsonObject();
    user.put("id", 1);
    user.put("name", "Subramanian");
    user.put("city", "Coimbatore");

fulent api:
   JsonObject user = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("city", "Coimbatore");
    promise.complete(user);

Nested Json and JSON array:
package com.amex.json;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JsonVerticle.class.getName());
  }

  public Future<JsonObject> getUser() {
    Promise promise = Promise.promise();
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("name", "Subramanian");
//    user.put("city", "Coimbatore");
//    promise.complete(user);

    //fluent way
    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .put("company", new JsonObject().put("name", "American Express"));

    promise.complete(user);

    return promise.future();
  }

  public Future<JsonArray> getUsers() {
    Promise<JsonArray> promise = Promise.promise();
    JsonArray users = new JsonArray()
      .add(new JsonObject()
        .put("id", 1)
        .put("name", "Subramanian")
        .put("city", "Coimbatore")
        .put("company", new JsonObject().put("name", "American Express"))).add(
        new JsonObject()
          .put("id", 2)
          .put("name", "Murugan")
          .put("city", "Coimbatore")
          .put("company", new JsonObject().put("name", "American Express"))
      );
    promise.complete(users);

    return promise.future();
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println("Id " + user.getInteger("id"));
      System.out.println("Name " + user.getString("name"));
      System.out.println("City " + user.getString("city"));
      System.out.println(user.encodePrettily());
    });
    getUsers().onSuccess(users -> {
      System.out.println(users.encodePrettily());
    });
  }
}
.........

Merging:
........
package com.amex.json;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

public class JsonVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JsonVerticle.class.getName());
  }

  public Future<JsonObject> getUser() {
    Promise promise = Promise.promise();
//    JsonObject user = new JsonObject();
//    user.put("id", 1);
//    user.put("name", "Subramanian");
//    user.put("city", "Coimbatore");
//    promise.complete(user);

    JsonObject skills = new JsonObject()
      .put("skillId", 1)
      .put("skill", new JsonArray()
        .add("Java")
        .add("Vertx")
        .add("Spring Boot")
        .add("Quarkus")
      );

    //fluent way
    JsonObject user = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .mergeIn(skills)
      .put("company", new JsonObject().put("name", "American Express"));

    promise.complete(user);

    return promise.future();
  }

  public Future<JsonArray> getUsers() {
    Promise<JsonArray> promise = Promise.promise();
    JsonArray users = new JsonArray()
      .add(new JsonObject()
        .put("id", 1)
        .put("name", "Subramanian")
        .put("city", "Coimbatore")
        .put("company", new JsonObject().put("name", "American Express"))).add(
        new JsonObject()
          .put("id", 2)
          .put("name", "Murugan")
          .put("city", "Coimbatore")
          .put("company", new JsonObject().put("name", "American Express"))
      );
    promise.complete(users);

    return promise.future();
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getUser().onSuccess(user -> {
      System.out.println("Id " + user.getInteger("id"));
      System.out.println("Name " + user.getString("name"));
      System.out.println("City " + user.getString("city"));
      System.out.println(user.encodePrettily());
    });
    getUsers().onSuccess(users -> {
      System.out.println(users.encodePrettily());
    });
  }
}
.....................................................................................
			Non Blocking Web Applications
.....................................................................................

HTTP server Application:

1.Vertx Provides webserver, you dont need to deploy vertx apps on Tomcat like container.
2.Vertx Webserver is fully non blocking, powered with event loop threads
3.Vertx Webserver is based "Shared Thread Model"

vertx.createHttpServer()...

Steps:
1.create webserver
2.write request handler
3.deploy the code into web server.

Interfaces:
1.HttpServer
2.HttpServerRequest
3.HttpServerResponse

package com.amex.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Handler;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.http.HttpServerResponse;

public class SimpleHttpVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", SimpleHttpVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Server
    HttpServer httpServer = vertx.createHttpServer();

    //Your application code: Request and Response handling
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      response.end("Hello");
    });
    //deploy and start server
    httpServer.listen(3000, httpServerHandler -> {
      if (httpServerHandler.succeeded()) {
        System.out.println("Server is Up @" + httpServerHandler.result().actualPort());
      } else {
        System.out.println("Server start up failed " + httpServerHandler.cause().getMessage());
      }
    });

  }
}
....

Fluent web server:

package com.amex.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.http.HttpServerResponse;

public class FluentWebServer extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FluentWebServer.class.getName());
  }

  private static void handle(HttpServerRequest request) {
    request.response().end("Hello!");
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
//    vertx.createHttpServer()
//      .requestHandler(request -> request.response().end("Hello"))
//      .listen(3000, handler -> {
//        System.out.println("Vertx Server is Running!");
//      });

    vertx.createHttpServer()
      .requestHandler(FluentWebServer::handle)
      .listen(3000, handler -> {
        System.out.println("Vertx Server is Running!");
      });
  }
}
.....................................................................................
			  Micro services API development
.....................................................................................

What is API?
  Application programming interface

In any software, data is center point, programs talks each other in order to exchange data.

How data is exchanged among or between programs?

 Every program expose "method/function/procedure" to exchange data.
 "method/function/procedure" is generally called as "API".

 Now a days most of programming languages uses "object oriented model" to design apis

 Object represents collection of "api". Object encapuslate apis....
 
 Object technically called as "End Point".

Types of api based on accessability:

1.Local api
   apis are communciated within single runtime eg witin single jvm/webserver
2.Remote api
  apis are commmunicated outside runtime via networks using network protocals.

When we think about distributed computing so called Microservices, apis are exposed via network only.

RPI: (Remote P
rocedure Invocation).

We have RPI lot of RPI technology...(api developement)

1.Web services -HTTP 1.1
   REST
   SOAP
   GRAPHQL

2.RPC
   CORBA
   RMI
   DCOM
   EJB
   GRPC - Modern RPC Framework -HTTP 2/TCP
   Websocket -WS

3.MOM 
   JMS
   Kakfa
   RabbitMQ
   IBMMQ

How to build REST API?

Resource  - Domain Model which is represented by Object having apis
Resource identifier -URI  ="/api"
Resource Method - GET,POST,PUT,DELETE - API verbs

package com.amex.http;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;

public class SimpleHTTPApi extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", SimpleHTTPApi.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.createHttpServer().requestHandler(request -> {
      //building rest api -  url and method
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.GET) {
        request.response().setStatusCode(200).end("USERS Get");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.POST) {
        request.response().setStatusCode(200).end("USERS Post");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.PUT) {
        request.response().setStatusCode(200).end("USERS Put");
      }
      if (request.uri().equals("/api/users") && request.method() == HttpMethod.DELETE) {
        request.response().setStatusCode(200).end("USERS DELETE");
      }
    }).listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is Running");
      } else {
        System.out.println("Server start up failed");
      }
    });
  }
}

in order to build rest api we need url and method for each resource, in the above code, we have verified method and url.

The develper has to write all method and resource mapping logic..
There is no proper  modularity in building apps

Soultion:
 Vertx provides a small framework/module for abstracting these things vertx-web

Vertx-Web:

Vertx-core provides a fairly low level set of functionality for handling http.
Vertx web builds on the top of vertx-core to provide a richer set of functionality for building real web applications more easily.

Vertx web is a greate fit for writing RESTfull Http microservices 


Features of Vertx-Web:
.......................

1.Routing (based on method,path,etc)
2.Regular expression based pattern matching for paths
3.Extract path parameters from paths.
4.Content negotiation
5.Request body handling
6.Multi part file uploads
7.Sub Routers
8.Session Support
9.CORS handling
10.Error Page handling
11.Authentication and authorization using jwt,http,oauth2
12.Template supports
etc...


Vertx Web Core Features:

1.Router:
  Router is one of the core concepts vertx-web
  It is object which maintains zero or more routes("url mappers")
  Router takes an http request and finds the matching routing for that request
  Every route has handler which process requests and send response

2.RoutingContext
   It is container object from which you can get Request and Response Objects

Basic routing:
package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class SimpleWebAPI extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", SimpleWebAPI.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //route handler: Request handler
    router.route().handler(ctx -> {
      HttpServerResponse response = ctx.response();
      response.setStatusCode(200);
      response.putHeader("content-type", "application/json");
      JsonObject jsonObject = new JsonObject().put("message", "Hello Vertx");
      response.end(jsonObject.encodePrettily());
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!");
      }
    });

  }
}
....................................................................................

Routers:

 URL mapping

Router router = Router.router(vertx);

1.router.route(HTTPMethod.GET,"url").handler(ctx->{})
2.router.get("url").handler | router.post("url").handler ...


package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class URLMapperWeb extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", URLMapperWeb.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.post("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}
.....................................................................................				How to read Payload
.....................................................................................

ctx.getBodyAsJson () method is used to read payload.

package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class RequestPayload extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", RequestPayload.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.post("/api/users").handler(ctx -> {
      JsonObject payload = ctx.getBodyAsJson();
      System.out.println(payload.encodePrettily());
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}

After running this code , you will get error? or you will will get null?

in order to read json we need to set json parser (middlewares)

middlewares are just code , get initalized before route is handled.

There is middleware called BodyHandler middleware.
package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class RequestPayload extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", RequestPayload.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //initialize the middleware
    //here we apply middleware for all router
    router.route().handler(BodyHandler.create());

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.post("/api/users").handler(ctx -> {
      //current vertx deprecated this api
      //JsonObject payload = ctx.getBodyAsJson();
      //lastest vertx api body
      JsonObject payload = ctx.body().asJsonObject();
      System.out.println(payload);
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}
.....................................................................................
			 Parameters 

1.Path Parameters
2.Query Parameters

Path Parameters:

Router router = Router.router(vertx);
router.get('/api/users/:id').handler(ctx)
String param = ctx.pathParam("id")

package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class PathParameter extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PathParameter.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //initialize the middleware
    //here we apply middleware for all router
    router.route().handler(BodyHandler.create());

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.get("/api/users/:id").handler(ctx -> {
      String id = ctx.pathParam("id");
      ctx.response().setStatusCode(200).end("USERS -GET" + id);
    });

    router.post("/api/users").handler(ctx -> {
      //current vertx deprecated this api
      //JsonObject payload = ctx.getBodyAsJson();
      //lastest vertx api body
      JsonObject payload = ctx.body().asJsonObject();
      System.out.println(payload);
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}
....................................................................................
			  Query Parameters

Router router = Router.router(vertx);
router.get('/api/users/:id').handler(ctx)
String param = ctx.queryParameter("id")
package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

import java.util.List;

public class QueryParameter extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", QueryParameter.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();

    //Request handling logic will be inside router
    Router router = Router.router(vertx);

    //initialize the middleware
    //here we apply middleware for all router
    router.route().handler(BodyHandler.create());

    //Resources: USER resource
    router.get("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -GET");
    });

    router.get("/api/users/location").handler(ctx -> {
      System.out.println("location");
      List<String> city = ctx.queryParam("city");
      System.out.println(city);
      city.forEach(System.out::println);
      ctx.response().setStatusCode(200).end("USERS -GET");
    });
    router.get("/api/users/:id").handler(ctx -> {
      String id = ctx.pathParam("id");
      ctx.response().setStatusCode(200).end("USERS -GET" + id);
    });

    router.post("/api/users").handler(ctx -> {
      //current vertx deprecated this api
      //JsonObject payload = ctx.getBodyAsJson();
      //lastest vertx api body
      JsonObject payload = ctx.body().asJsonObject();
      System.out.println(payload);
      ctx.response().setStatusCode(201).end("USERS -POST");

    });
    router.put("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -PUT");

    });
    router.delete("/api/users").handler(ctx -> {
      ctx.response().setStatusCode(200).end("USERS -DELETE");
    });
    //assign router to request handler
    httpServer.requestHandler(router);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      }
    });

  }
}
....................................................................................
			  Resource oriented Routers
....................................................................................

Domain models

api/users
api/products
api/customers
api/items

What if i have more resources and more routes?

ProductRouter ---- /api/products
UserRouter -----/api/users
PaymentRouter ---/api/payments

if you have more than one router , how to bind with request handler

 httpServer.requestHandler(?);

SubRouters and MainRouters

-You can have more subRouters - products,users etc..
-You can have only one main or app router- appRouter
-requestHandler takes appRouter
->Inside App Router we have to configure subrouters
 
How to bind /mount/connect app router with subrouter?

Router router = Router.router(vertx);

router.mountSubRouter() - old one

appRouter.route("/api/users/*").subRouter(userRouter) ; - new One

Rules:
1.The route path must end with a wild card "/*"
2.Parameters are allowed but full regex pattern not
3.Only one handler can be registered.
2.Only one router per path object

Full code:
package com.amex.http.web.subrouters;

import com.amex.http.web.PathParameter;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class ResourceRouters extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ResourceRouters.class.getName());
  }

  //router class : inner classes
  private static class UserRouter {
    //CURD operations
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.body().asJsonObject();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("User saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("User List");
    }
  }

  private static class ProductRouter {
    //CURD operations
    public static void create(RoutingContext ctx) {
      JsonObject user = ctx.body().asJsonObject();
      System.out.println(user.encodePrettily());
      ctx.response().setStatusCode(201).end("Product saved");
    }

    public static void list(RoutingContext ctx) {
      ctx.response().setStatusCode(200).end("Product List");
    }
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Create Http server
    HttpServer httpServer = vertx.createHttpServer();
    //Request handling logic will be inside router
    //create sub routers
    Router userRouter = Router.router(vertx);
    Router productRouter = Router.router(vertx);
    Router customerRouter = Router.router(vertx);
    //appRouter
    Router appRouter = Router.router(vertx);
    //initialize the middleware
    //here we apply middleware for all router
    appRouter.route().handler(BodyHandler.create());


    //URL Patterns
    //http://localhost:3000/api/users/list
    userRouter.get("/list").handler(UserRouter::list);
    userRouter.post("/save").handler(UserRouter::create);

    //Products
    productRouter.get("/list").handler(ProductRouter::list);
    productRouter.post("/save").handler(ProductRouter::create);


    //appRouter with subRouter binding
    //old api: depricated api
//     appRouter.mountSubRouter("/api/users", userRouter);
    //new api
    appRouter.route("/api/users/*").subRouter(userRouter);
    //appRouter.mountSubRouter("/api/products", productRouter);
    appRouter.route("/api/products/*").subRouter(productRouter);

    //assign router to request handler
    httpServer.requestHandler(appRouter);

    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      } else {

      }
    });

  }
}
....................................................................................
			  Exception Handling
.....................................................................................

if some thing went wront how to handle exception and how to send error message to clients.

router.failureHandler(handler->{
   send error data to client and tools
})

package com.amex.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class ExceptionHandlingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", ExceptionHandlingVerticle.class.getName());
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router userRouter = Router.router(vertx);
    Router appRouter = Router.router(vertx);
    HttpServer httpServer = vertx.createHttpServer();

    appRouter.route("/api/users/*").subRouter(userRouter);


    userRouter.get("/list/:name").handler(ctx -> {
      String name = ctx.pathParam("name");
      if (name.equals("admin")) {
        ctx.response().end("You are valid user");
      } else {
        throw new RuntimeException("invalid user");
      }
    }).failureHandler(ctx -> {
      int statusCode = ctx.statusCode();
      String message = ctx.failure().getMessage();
      JsonObject errorMessages = new JsonObject().put("code", statusCode).put("message", message);
      ctx.response().setStatusCode(statusCode).end(errorMessages.encodePrettily());
    });
    //assign router to request handler
    httpServer.requestHandler(appRouter);
    //start server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Vertx Server is running!!");
      } else {

      }
    });
  }
}

Handlers Types:

1.router.handler() - async request handling
2.router.failureHandler() - async exception /error handler

Global Handlers
BodyHandler -  Converts jsonString to jsonObject
TimeoutHandler  - to Request timeout for given url or global
blockingHandlier - for writing blocking code...
....................................................................................
			 Vertx  and Datasources
.....................................................................................

Vertx supports nonblocking database access..
Vertx Provides nonblocking drivers to communicate with relational and nosql databases..

1.JDBC Client
2.PostgreSQL
3.MySQL
4.DB2
5.Mongodb
6.Redis
7.Cassandra 

JDBC Client:

=>JDBC is a technolgy through which you can talk to relational database.
=>As of now JPA ,hibernate ORM is not supported by vertx.
=>JDBC code you can write in two ways callback pattern, reactive patterns

in order to write database code we have two apis

1.JDBCClient - Legacy , you can avoid 
2.SqlClient API 
   Sql is abstraction api which provides easy way of querying data from databases
  JdbcPool Instance to perform SQL operations - INSERT,DELETE,UPDATE,SELECT
  You can write preparedStatements and callable statements.

1.jdbc dependency
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-jdbc-client</artifactId>
    </dependency>

database driver dependency

<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <version>2.3.2</version>
 </dependency>



2.Configuring connections
   JsonObject connectionInfo = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");

 JDBCClient client= JDBCClient.createShared(vertx, connectionInfo);

3.You have to use callback chain pattern.
    connection success
            |
            do sql operations
   else 
    throw erro
   client.getConnection(connection->{
        if(connection.succeeded(){

         }
   })
			
3.Get sqlConnection instance

 client.getConnection(connection->{
        if(connection.succeeded(){
	final SQLConnecton con=connection.result()
         }
   })

4. You can execute Query

 client.getConnection(connection->{
        if(connection.succeeded(){
	final SQLConnecton con=connection.result()
	  con.execute(sql,handler())
         }
   })

Callback Based JDBC code using JDBCClient API
package com.amex.http.jdbc;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import jdk.jshell.ImportSnippet;

public class JDBCVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JDBCVerticle.class.getName());
  }

  public void prepareDatabase() {
    JsonObject connectionInfo = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");

    JDBCClient jdbcClient = JDBCClient.createShared(vertx, connectionInfo);
    jdbcClient.getConnection(connection -> {
      if (connection.succeeded()) {
        System.out.println("connection success");
        SQLConnection sqlConnection = connection.result();
        //table creation
        String CREATE_TABLE = "CREATE TABLE user(id int primary key, name varchar(255))";
        sqlConnection.execute(CREATE_TABLE, tableCreate -> {
          if (tableCreate.succeeded()) {
            System.out.println("table is created");
            String INSERT_QUERY = "INSERT INTO user VALUES(1,'subramanian')";
            sqlConnection.execute(INSERT_QUERY, tableInsert -> {
              if (tableInsert.failed()) {
                System.out.println(tableInsert.cause().getMessage());
              } else {
                String SELECT_QUERY = "SELECT * FROM user";
                sqlConnection.query(SELECT_QUERY, tableSelect -> {
                  System.out.println(tableSelect.result().getResults());
                });	
              }
            });
          } else {
            System.out.println("Table not created" + tableCreate.cause().getMessage());
          }
        });
      } else {
        System.out.println("Connection failed" + connection.cause().getMessage());
      }
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    prepareDatabase();
  }
}
......................................................................................

JdbPool:
    JsonObject config = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");
    //Pool is ready
    JDBCPool pool = JDBCPool.pool(vertx, config);

Query Operations:CREATE,INSERT,SELECT,UPDATE,DELETE

pool.query(QUERY)
.execute()
.onFailure()
.onSuccess(rows->{})

pool.preparedQuery("query")
  .execute(Tuple.of(value))
  .onFailure()
  .onSuccess()

package com.amex.http.jdbc;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.Row;

public class JDBCPoolVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", JDBCPoolVerticle.class.getName());
  }

  public void prepareDb() {
    JsonObject config = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver")
      .put("max_pool_size", 30)
      .put("user", "SA")
      .put("password", "");
    //Pool is ready
    JDBCPool pool = JDBCPool.pool(vertx, config);
    //create,insert,select
    pool
      .query("create table test(id int primary key,name varchar(255))")
      .execute()
      .compose(r ->
        pool.query("insert into test values(1,'subramanian'),(2,'murugan')").execute()
      ).compose(r -> pool.query("select * from test").execute())
      .onSuccess(rows -> {
        for (Row row : rows) {
          System.out.println(row.toJson());
        }
      }).onFailure(System.out::println);

  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    prepareDb();
  }
}
...................

Use case : 
CREATE REST API FOR "Products" 
Product id, product name, product price, product qty

Req:
Web
 /api/products - list all products
 /api/products/id - get one product
 /api/products -  save
 /api/products  - update
 /api/products  - remove

JDBC layer - H2 db, jdbc Pool
















